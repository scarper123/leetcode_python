150 ms 45 lines JAVA solution
    public List<List<Integer>> palindromePairs(String[] words) {
        List<List<Integer>> ret = new ArrayList<>(); 
        if (words == null || words.length < 2) return ret;
        Map<String, Integer> map = new HashMap<String, Integer>();
        for (int i=0; i<words.length; i++) map.put(words[i], i);
        for (int i=0; i<words.length; i++) {
            // System.out.println(words[i]);
            for (int j=0; j<=words[i].length(); j++) { // notice it should be "j <= words[i].length()"
                String str1 = words[i].substring(0, j);
                String str2 = words[i].substring(j);
                if (isPalindrome(str1)) {
                    String str2rvs = new StringBuilder(str2).reverse().toString();
                    if (map.containsKey(str2rvs) && map.get(str2rvs) != i) {
                        List<Integer> list = new ArrayList<Integer>();
                        list.add(map.get(str2rvs));
                        list.add(i);
                        ret.add(list);
                        // System.out.printf("isPal(str1): %s\n", list.toString());
                    }
                }
                if (isPalindrome(str2)) {
                    String str1rvs = new StringBuilder(str1).reverse().toString();
                    // check "str.length() != 0" to avoid duplicates
                    if (map.containsKey(str1rvs) && map.get(str1rvs) != i && str2.length()!=0) { 
                        List<Integer> list = new ArrayList<Integer>();
                        list.add(i);
                        list.add(map.get(str1rvs));
                        ret.add(list);
                        // System.out.printf("isPal(str2): %s\n", list.toString());
                    }
                }
            }
        }
        return ret;
    }
    
    private boolean isPalindrome(String str) {
        int left = 0;
        int right = str.length() - 1;
        while (left <= right) {
            if (str.charAt(left++) !=  str.charAt(right--)) return false;
        }
        return true;
    }


1. The `<=` in `for (int j=0; j<=words[i].length(); j++)` is aimed to handle empty string in the input. Consider the test case of ["a", ""];

2.  Since we now use `<=` in `for (int j=0; j<=words[i].length(); j++)` instead of `<`. There may be duplicates in the output (consider test case ["abcd", "dcba"]). Therefore I put a `str2.length()!=0` to avoid duplicates.



Another way to avoid duplicates is to use `Set<List<Integer>> ret = new HashSet<>();` and return `new ArrayList<>(ret);`

----------------------------------------------------------------------------------------------------
O(n*k^2) java solution with Trie structure (n: total number of words; k: average length of each word)
Apparently there is a O(n^2*k) naive solution for this problem, with n the total number of words in the "words" array and k the average length of each word: 

**For each word, we simply go through the "words" array and check whether the concatenated string is a palindrome or not.** 

Of course this will result in TLE as expected. To improve the algorithm, we need to reduce the number of words that is needed to check for each word, instead of iterating through the whole array. This prompted me to think if I can extract any useful information out of the process of checking whether the concatenated string is a palindrome, so that it can help eliminate as many words as possible for the rest of the "words" array. 

First here is the technique I employed to check palindrome: maintain two pointers, i and j, with i pointing to the beginning of the string, j pointing to the end of the string. Characters pointed by i and j are compared. If at any time the characters pointed by them are not the same, we conclude the string is not a palindrome. Otherwise we move the two pointers towards each other until they meet in the middle and the string is a palindrome.

By examining the above process, I do find something that we may take advantage of to get rid of words that need to be checked. For example, let's say we want to append words to w0, which starts with character 'a'. Then we only need to consider words ending with character 'a', i.e., this will single out all words ending with character 'a'. If the second character of w0 is 'b' for instance, we can further reduce our candidate set to words ending with string "ba", etc. Our naive solution throws all the information away and repeats the comparison, which leads to the undesired O(n^2*k) complexity.

In order to exploit the information gathered so far, we obviously need to restructure all the words in the "words" array. If you are familiar with Trie structure (I believe you are, since LeetCode has problems for it. In case you are not, see [Trie][1]), it will come to mind as we need to deal with words with common suffixes. The next step is to design fields for each node in the Trie. There are at least two fields that should be covered for each TrieNode: a TrieNode array denoting the next layer of nodes and a boolean (or integer) to signify the end of a word. So our tentative TrieNode will look like this:

    class TrieNode {
          TrieNode[] next;
          boolean isWord;
     }

One point here is that we assume all the words contain lowercase letters only. This is not specified in the problem statement so you probably need to confirm with the interviewer (here I assume it is the case)

Now we will rearrange each word into this Trie structure: simply starting from the root of the Trie and the ending character of each word, identify the node at the next layer by indexing into root's "next" array with index given by the difference between the ending character and character 'a'. If the indexed node is null, create a new node.  Continue to the next layer and towards the beginning of the word in this manner until we are done with the word, at which point we will label the "isWord" field of the final node as true.

After building up the Trie structure, we can proceed to search for pairs of palindromes for each word in the "words" array. I will use the following example to explain how it works and make possible modifications of the TrieNode we proposed above.

Let's say we have these words: ["ba", "a", "aaa"], the Trie structure will be as follows:

            root (f)
               | 'a'
              n1 (t)
         ------------
     'b' |          | 'a'
        n2 (t)    n3 (f)
                    | 'a'
                  n4 (t)
 The letter in parentheses indicates the value of "isWord" for each node: f ==> false; t ==> true. The character at each vertical line denotes the index into the "next" array of the corresponding node. For example, for the first vertical line, 'a' means root.next[0] is not null. Similarly 'b' means n1.next\[1] is not null, and so on.

Here is the searching process: 

 1. For word "ba", starting from the first character 'b', index into the root.next array with index ('b' - 'a' = 1). The corresponding node is null, then we know there are no words ending at this character, so the search is terminated;
 2. For word "a", again indexing into array root.next at index ('a' - 'a' = 0) will yield node n1, which is not null. We then check the value of n1.isWord. If it is true, then it is possible to obtain a palindrome by appending this word to the one currently being examined (a.k.a. word "a"). Also note that the two words should be different, but the n1.isWord field provides no information about the word itself, which makes it impossible to distinguish the two words. So we need to modify the fields of the TrieNode so we can identify the word it represents. One easy way is to have an integer field to remember the index of the word in the "words" array. For non-word nodes, this integer will take negative values (-1 for example) while for those representing a word, it will be non-negative values. Suppose we have made this modification, then we know the two words are the same, so we discard this pair combination. Since the word "a" has only one letter, it seems we are done with it. Or do we? Not really. What if we have words with suffix "a" ("aaa" in this case)? We need to continue check the rest part of these words (such as "aa" for the word "aaa") and see if the rest forms a palindrome. If it is, then appending this word ("aaa" in this case) to the original word ("a") will also form a palindrome ("aaaa"). Here I take another strategy: add an integer list to each TrieNode; the list will record the indices of all words satisfying the following two conditions: each word has a suffix represented by the current Trie node; the rest of the word forms a palindrome.

Before I get to the third word "aaa", let me spell out the new TrieNode and the corresponding Trie structure for the above array.

    class TrieNode {
         TrieNode[] next;
         int index;
         List<Integer> list;
            
        TrieNode() {
           next = new TrieNode[26];
           index = -1;
           list = new ArrayList<>();
        }
    }

Trie structure:

              root (-1,[1,2])
                | 'a'
              n1 (1,[0,1,2])
        ---------------------
    'b' |                  | 'a'
      n2 (0,[0])    n3 (-1,[2])
                           | 'a'
                     n4 (2,[2])

 The first integer in the parentheses is the index of the word in the "words" array (defaulted to -1). The integers in the square bracket are the indices of words satisfying the two conditions mentioned above.

Let's continue with the third word "aaa" with this new structure. Indexing into array root.next at index ('a' - 'a' = 0) will yield node n1 and n1.index = 1 >= 0, which is also different from the index of "aaa" (which is 2). So pair (2,1) is a possible concatenation to form a palindrome. But still we need to check the rest of "aaa" (excluding the string represented by current n1 which is "a" from the beginning of "aaa") to see if it is a palindrome. If it is, then (2,1) is a valid combination. We continue in this fashion until we reach the end of "aaa". Lastly we will check n4.list to see if there are any words satisfying the two conditions specified in step 2 which are different from current word, and add the corresponding valid pairs.

Both building and searching the Trie structure take O(n*k^2), which set the total time complexity of the solution. See the complete Java program in the answer.

  [1]: https://en.wikipedia.org/wiki/Trie

----------------------------------------------------------------------------------------------------
Easy to understand AC C++ solution O(n*k^2) using map
**Assumption**: No duplicated string in the given dictionary

**Steps:**

1. Traverse the array, build map. Key is the reversed string, value is index in array (0 based)

2. Edge case - check if empty string exists. It's interesting that for given words {"a", ""}, it's expected to return two results [0,1] and [1,0]. Since my main logic can cover [0, 1] concatenate("a", ""), so as to cover the other situation concatenate("", "a"), I need to traverse the words array again, find the palindrome word candidate **except** "" itself, and add pair("", palindrome word) to the final answer.

3. Main logic part. Partition the word into left and right, and see 1) if there exists a candidate in map equals the left side of current word, and right side of current word is palindrome, so concatenate(current word, candidate) forms a pair: **left** | right | **candidate**. 2) same for checking the right side of current word: **candidate** | left | **right**.



        class Solution {
        public:
            vector<vector<int>> palindromePairs(vector<string>& words) {
                unordered_map<string, int> dict;
                vector<vector<int>> ans;
                // build dictionary
                for(int i = 0; i < words.size(); i++) {
                    string key = words[i];
                    reverse(key.begin(), key.end());
                    dict[key] = i;
                }
                // edge case: if empty string "" exists, find all palindromes to become pairs ("", self)
                if(dict.find("")!=dict.end()){
                    for(int i = 0; i < words.size(); i++){
                        if(i == dict[""]) continue;
                        if(isPalindrome(words[i])) ans.push_back({dict[""], i}); // 1) if self is palindrome, here ans covers concatenate("", self) 
                    }
                }

                for(int i = 0; i < words.size(); i++) {
                    for(int j = 0; j < words[i].size(); j++) {
                        string left = words[i].substr(0, j);
                        string right = words[i].substr(j, words[i].size() - j);

                        if(dict.find(left) != dict.end() && isPalindrome(right) && dict[left] != i) {
                            ans.push_back({i, dict[left]});     // 2) when j = 0, left = "", right = self, so here covers concatenate(self, "")
                        }

                        if(dict.find(right) != dict.end() && isPalindrome(left) && dict[right] != i) {
                            ans.push_back({dict[right], i});
                        }
                    }
                }

                return ans;        
            }

            bool isPalindrome(string str){
                int i = 0;
                int j = str.size() - 1; 

                while(i < j) {
                    if(str[i++] != str[j--]) return false;
                }

                return true;
            }

        };

----------------------------------------------------------------------------------------------------
The Easy-to-unserstand JAVA Solution
There are several cases to be considered that isPalindrome(s1 + s2):

Case1: If s1 is a blank string, then for any string that is palindrome s2, s1+s2 and s2+s1 are palindrome.

Case 2: If s2 is the reversing string of s1, then s1+s2 and s2+s1 are palindrome.

Case 3: If s1[0:cut] is palindrome and there exists s2 is the reversing string of s1[cut+1:] , then s2+s1 is palindrome.

Case 4: Similiar to case3. If s1[cut+1: ] is palindrome and there exists s2 is the reversing string of s1[0:cut] , then s1+s2 is palindrome.

To make the search faster, build a HashMap to store the String-idx pairs.

My code:

    public class Solution {
    public List<List<Integer>> palindromePairs(String[] words) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        if(words == null || words.length == 0){
            return res;
        }
        //build the map save the key-val pairs: String - idx
        HashMap<String, Integer> map = new HashMap<>();
        for(int i = 0; i < words.length; i++){
            map.put(words[i], i);
        }
        
        //special cases: "" can be combine with any palindrome string
        if(map.containsKey("")){
            int blankIdx = map.get("");
            for(int i = 0; i < words.length; i++){
                if(isPalindrome(words[i])){
                    if(i == blankIdx) continue;
                    res.add(Arrays.asList(blankIdx, i));
                    res.add(Arrays.asList(i, blankIdx));
                }
            }
        }
        
        //find all string and reverse string pairs
        for(int i = 0; i < words.length; i++){
            String cur_r = reverseStr(words[i]);
            if(map.containsKey(cur_r)){
                int found = map.get(cur_r);
                if(found == i) continue;
                res.add(Arrays.asList(i, found));
            }
        }
        
        //find the pair s1, s2 that 
        //case1 : s1[0:cut] is palindrome and s1[cut+1:] = reverse(s2) => (s2, s1)
        //case2 : s1[cut+1:] is palindrome and s1[0:cut] = reverse(s2) => (s1, s2)
        for(int i = 0; i < words.length; i++){
            String cur = words[i];
            for(int cut = 1; cut < cur.length(); cut++){
                if(isPalindrome(cur.substring(0, cut))){
                    String cut_r = reverseStr(cur.substring(cut));
                    if(map.containsKey(cut_r)){
                        int found = map.get(cut_r);
                        if(found == i) continue;
                        res.add(Arrays.asList(found, i));
                    }
                }
                if(isPalindrome(cur.substring(cut))){
                    String cut_r = reverseStr(cur.substring(0, cut));
                    if(map.containsKey(cut_r)){
                        int found = map.get(cut_r);
                        if(found == i) continue;
                        res.add(Arrays.asList(i, found));
                    }
                }
            }
        }
        
        return res;
    }
    
    public String reverseStr(String str){
        StringBuilder sb= new StringBuilder(str);
        return sb.reverse().toString();
    }
    
    public boolean isPalindrome(String s){
        int i = 0;
        int j = s.length() - 1;
        while(i <= j){
            if(s.charAt(i) != s.charAt(j)){
                return false;
            }
            i++;
            j--;
        }
        return true;
    }
}

----------------------------------------------------------------------------------------------------
Accepted short Java solution using HashMap

    public List<List<Integer>> palindromePairs(String[] words) {
        List<List<Integer>> pairs = new LinkedList<>();
        if (words == null) return pairs;
        HashMap<String, Integer> map = new HashMap<>();
        for (int i = 0; i < words.length; ++ i) map.put(words[i], i);
        for (int i = 0; i < words.length; ++ i) {
            int l = 0, r = 0;
            while (l <= r) {
                String s = words[i].substring(l, r);
                Integer j = map.get(new StringBuilder(s).reverse().toString());
                if (j != null && i != j && isPalindrome(words[i].substring(l == 0 ? r : 0, l == 0 ? words[i].length() : l)))
                    pairs.add(Arrays.asList(l == 0 ? new Integer[]{i, j} : new Integer[]{j, i}));
                if (r < words[i].length()) ++r;
                else ++l;
            }
        }
        return pairs;
    }
    
    private boolean isPalindrome(String s) {
        for (int i = 0; i < s.length()/2; ++ i)
            if (s.charAt(i) != s.charAt(s.length()-1-i))
                return false;
        return true;
    }


----------------------------------------------------------------------------------------------------
Python solution~
        wordict = {}
        res = [] 
        for i in range(len(words)):
            wordict[words[i]] = i
        for i in range(len(words)):
            for j in range(len(words[i])+1):
                tmp1 = words[i][:j]
                tmp2 = words[i][j:]
                if tmp1[::-1] in wordict and wordict[tmp1[::-1]]!=i and tmp2 == tmp2[::-1]:
                    res.append([i,wordict[tmp1[::-1]]])
                if j!=0 and tmp2[::-1] in wordict and wordict[tmp2[::-1]]!=i and tmp1 == tmp1[::-1]:
                    res.append([wordict[tmp2[::-1]],i])
                    
        return res

----------------------------------------------------------------------------------------------------
Accepted Python Solution With Explanation
The basic idea is to check each word for prefixes (and suffixes) that are themselves palindromes.  If you find a prefix that is a valid palindrome, then the suffix reversed can be paired with the word in order to make a palindrome.  It's better explained with an example.

    words = ["bot", "t", "to"]

Starting with the string "bot".  We start checking all prefixes.  If `"", "b", "bo", "bot"` are themselves palindromes.  The empty string and "b" are palindromes.  We work with the corresponding suffixes ("bot", "ot") and check to see if their reverses ("tob", "to") are present in our initial word list.  If so (like the word to"to"), we have found a valid pairing where the reversed suffix can be **prepended** to the current word in order to form "to" + "bot" = "tobot".

You can do the same thing by checking all suffixes to see if they are palindromes.  If so, then finding all reversed prefixes will give you the words that can be **appended** to the current word to form a palindrome.

The process is then repeated for every word in the list.  Note that when considering suffixes, we explicitly leave out the empty string to avoid counting duplicates.  That is, if a palindrome can be created by appending an entire other word to the current word, then we will already consider such a palindrome when considering the empty string as prefix for the other word.  

        def is_palindrome(check):
            return check == check[::-1]
    
        words = {word: i for i, word in enumerate(words)}
        valid_pals = []
        for word, k in words.iteritems():
            n = len(word)
            for j in range(n+1):
                pref = word[:j]
                suf = word[j:]
                if is_palindrome(pref):
                    back = suf[::-1]
                    if back != word and back in words:
                        valid_pals.append([words[back],  k])
                if j != n and is_palindrome(suf):
                    back = pref[::-1]
                    if back != word and back in words:
                        valid_pals.append([k, words[back]])
        return valid_pals

----------------------------------------------------------------------------------------------------
Problem statement needs improvement
There is no requirement that states i and j should be different  in (i, j) pairs.
So in example 2 (3, 3) should lead to 'ss' which is a palindrome.
Problem statement should be corrected as:

 Find all pairs of ***distinct*** indices (i, j) in the given list, so that 




----------------------------------------------------------------------------------------------------
Clean C++ implementation
class Solution {
public:
    vector<vector<int>> palindromePairs(vector<string>& words) {
        vector<vector<int>> result;
        unordered_map<string, int> dict;
        for(int i = 0; i < words.size(); i++) {
            dict[words[i]] = i;
        }
        for(int i = 0; i < words.size(); i++) {
            for(int j = 0; j <= words[i].length(); j++) {
                //check the suffix word
                if(is_palindrome(words[i], j, words[i].size() - 1)) {
                    /** the suffix word can be null to all the word **/
                    string suffix = words[i].substr(0, j);
                    reverse(suffix.begin(), suffix.end());
                    if(dict.find(suffix) != dict.end() && i != dict[suffix]) {
                        result.push_back({i, dict[suffix]});
                    }
                }
                //check the prefix word 
                if(j > 0 && is_palindrome(words[i], 0, j - 1)) {
                    string prefix = words[i].substr(j);
                    reverse(prefix.begin(), prefix.end());
                    if(dict.find(prefix) != dict.end() && dict[prefix] != i) {
                        result.push_back({dict[prefix], i});
                    }
                }
            }
        }
        return result;
    }
    
    bool is_palindrome(string& s, int start, int end) {
        while(start < end) {
            if(s[start++] != s[end--]) {
                return false;
            }
        }
        return true;
        
    }
};

----------------------------------------------------------------------------------------------------
Java naive 154 ms O(nk^2 + r) and 126 ms O(nk + r) Manacher + suffixes&#x2F;prefixes
**Added: a (not so) naive solution**

If two concatenated words form a palindrome, then there are three cases to consider:

    +---s1---+---s2--+     +---s1---+-s2-+    +-s1-+---s2---+
    |abcdefgh|hgfedcba|    |abcdxyyx|dcba|    |abcd|xyyxdcba|

Case 1 is when one string is a mirror image of another. Case 2 is when the first string is longer than the other and consists of the mirror image of the other (prefix) and a palindrome (suffix). Case 3 is a mirror image of case 2. Case 1 can also be considered a special subcase of either case 2 or case 3 with an empty palindrome suffix/prefix.

Of these three, case 1 is definitely the easiest because we just need to look up a word in a reverse string-to-index map (words are unique, so no multimaps needed). If we iterate over the list with `s1` as the current string, then case 2 is also much easier than case 3 because when we locate a prefix/palindrome split inside `s1` we just need to look up for the reversed prefix in the map.

Case 3 is trickier, but we can get rid of case 3 altogether if we just make another run with the reversed words! This way case 3 turns into case 2. We only need to consider case 1 in one of these runs in order to avoid duplicate combinations. With that in mind, I present the following 154 ms solution:

    public List<List<Integer>> palindromePairs(String[] words) {
        Map<String, Integer> index = new HashMap<>();
        Map<String, Integer> revIndex = new HashMap<>();
        String[] revWords = new String[words.length];
        for (int i = 0; i < words.length; ++i) {
            String s = words[i];
            String r = new StringBuilder(s).reverse().toString();
            index.put(s, i);
            revIndex.put(r, i);
            revWords[i] = r;
        }
        List<List<Integer>> result = new ArrayList<>();
        result.addAll(findPairs(words, revWords, revIndex, false));
        result.addAll(findPairs(revWords, words, index, true));
        return result;
    }
    
    private static List<List<Integer>> findPairs(String[] words, String[] revWords, Map<String, Integer> revIndex, boolean reverse) {
        List<List<Integer>> result = new ArrayList<>();
        for (int i = 0; i < words.length; ++i) {
            String s = words[i];
            for (int k = reverse ? 1 : 0; k <= s.length(); ++k) { // check suffixes, <= because we allow empty words
                Integer j = revIndex.get(s.substring(k));
                if (j != null && j != i) { // reversed suffix is present in the words list
                    // check whether the prefix is a palindrome
                    if (s.regionMatches(0, revWords[i], s.length() - k, k)) {
                        result.add(reverse ? Arrays.asList(i, j) : Arrays.asList(j, i));
                    }
                }
            }
        }
        return result;
    }

Now this was actually the third solution I came up with. The first one was really ugly because it considered all three cases separately. The second one is below.

**The ugly optimized solution**

As in other solutions posted here, I used Manacher's algorithm to quickly determine whether some part of a string is a palindrome or not. That gets rid of one O(nk^2) part, where `k` is the average word length and `n` is the number of words.

Another part is numerous calls to `substring`, so my idea is to avoid copying a substring unless there's a good chance that it's actually present in the list. I do this by creating a kind of ad-hoc hash tables for both reversed and non-reversed words.

We start by iterating over the list of the words and compute hashes for both reversed and non-reversed words. However, because I later calculate hashes of *suffixes* on the fly, which means that I calculate them right-to-left, so it is kind of mixed up which hash is reversed and which is not.

Then we just compute every suffix's hash and look up the matching words. Updating the hash as we go, we avoid O(nk^2) complexity and get O(nk) which is the best we can get since we *have* to analyze all words. To consider all cases, we do it twice, for reversed and non-reversed words.

    public List<List<Integer>> palindromePairs(String[] words) {
        List<List<Integer>> result = new ArrayList<>();
        int bCount = Integer.highestOneBit(words.length - 1) << 1; // round up to power of 2
        List<Integer>[] buckets = new List[bCount];
        List<Integer>[] revBuckets = new List[bCount];
        String[] revWords = new String[words.length];
        for (int i = 0; i < words.length; ++i) {
            String s = words[i];
            String r = new StringBuilder(s).reverse().toString();
            revWords[i] = r;
            int h = 0, hrev = 0;
            for (int j = 0; j < s.length(); ++j) {
                h = h * 17 + r.charAt(j); // will compute hash for suffixes in reversed order
                hrev = hrev * 17 + s.charAt(j); // so here s and r are swapped
            }
            h = (h & Integer.MAX_VALUE) % buckets.length;
            hrev = (hrev & Integer.MAX_VALUE) % revBuckets.length;
            if (buckets[h] == null) {
                buckets[h] = new ArrayList<>();
            }
            buckets[h].add(i);
            if (revBuckets[hrev] == null) {
                revBuckets[hrev] = new ArrayList();
            }
            revBuckets[hrev].add(i);
        }
        for (int i = 0; i < words.length; ++i) {
            String s = words[i];
            int[] m = manacher(s);
            for (int j : findPairs(s, m, 0, revBuckets, revWords)) {
                if (i != j) {
                    result.add(Arrays.asList(j, i));
                }
            }
            s = revWords[i];
            for (int j = 0, k = m.length - 1; j < k; ++j, --k) {
                int tmp = m[j];
                m[j] = m[k];
                m[k] = tmp;
            }
            for (int j : findPairs(s, m, 1, buckets, words)) {
                if (i != j) {
                    result.add(Arrays.asList(i, j));
                }
            }
        }
        return result;
    }
    
    private static List<Integer> findPairs(String s, int[] manacher, int end,
            List<Integer>[] buckets, String[] words) {
        List<Integer> pairs = new ArrayList<>();
        for (int i = s.length(), h = 0;; ) {
            assert i + manacher[i] <= 2 * i;
            if (i + manacher[i] == 2 * i) {
                List<Integer> bucket = buckets[(h & Integer.MAX_VALUE) % buckets.length];
                if (bucket != null) {
                    for (int j : bucket) {
                        if (s.length() - i == words[j].length() && s.regionMatches(i, words[j], 0, words[j].length())) {
                            pairs.add(j);
                        }
                    }
                }
            }
            if (--i < end) {
                break;
            }
            h = h * 17 + s.charAt(i);
        }
        return pairs;
    }
    
    private static int[] manacher(String s) {
        final int n = s.length() * 2 + 1;
        int[] p = new int[n];
        for (int i = 0, c = 0; i < n; ++i) {
            int r = c + p[c], il, ir;
            if (i > r) {
                il = i - 1;
                ir = i + 1;
            } else {
                int i2 = c - (i - c);
                if (i + p[i2] >= r) {
                    ir = r + 1;
                    il = i - (ir - i);
                    p[i] = r - i;
                } else {
                    p[i] = p[i2];
                    il = ir = -1; // skip the check
                }
            }
            while (il >= 0 && ir < n && ((il & 1) == 0 || s.charAt(il / 2) == s.charAt(ir / 2))) {
                ++p[i];
                --il;
                ++ir;
            }
            if (i + p[i] > r) {
                c = i;
            }
        }
        return p;
    }


----------------------------------------------------------------------------------------------------
My C++ solution (275ms), worst case O(N^2)
use a hashtable (unordered_map map) to save the mapping between string and its index and use a ordered set (wLen) to save all possible string lengths. Then go through each string, 
a) generate its reverse string temp
b) see if temp is in the map, if so, add (it, map[temp]) to res
c) check if it can concatenate a shorter string to generate a palindrome, then for each possible shorter length sL
  c1) check if we can add a sL-long string after the current string
  c2) check if we can add a sL-long string before the current one 

    class Solution {
    private:
        bool isP(string &s, int left, int right)
        { // check if s[left::right] is a palindrome
            while(left<right)
                if(s[left++] !=s[right--]) return false;
            return true;
        }
    
    public:
        vector<vector<int>> palindromePairs(vector<string>& words) {
            unordered_map<string, int> map;
            set<int> wLen;
            int it, len=words.size(), it2, sL, lL;
            vector<vector<int>> res;
    
            for(it=0; it<len; ++it) { //build map and the length set
                map[words[it]] = it;
                wLen.insert(words[it].size());
            }
    
            for(it=0; it<len; ++it)
            { // for each string
                string temp = words[it];
                lL = temp.size();
                std::reverse(temp.begin(), temp.end()); // reverse it, step a)
                if(map.count(temp) && map[temp]!=it)
                      res.push_back(vector<int>({it, map[temp]})); //step b)
                auto itC = wLen.find(words[it].size());
                for(auto itL=wLen.begin(); itL!=itC; ++itL)
                { // for each possible shorter length
                    sL = *itL;
                    if(isP(temp, 0, lL-sL-1) && map.count(temp.substr(lL-sL)))
                          res.push_back(vector<int>({it, map[temp.substr(lL-sL)]})); //step c1)
                    if(isP(temp, sL, lL-1) && map.count(temp.substr(0,sL)))
                         res.push_back(vector<int>({map[temp.substr(0,sL)], it})); //step c2)                       
                }
            }    
            return res;
        }
    };


----------------------------------------------------------------------------------------------------
Accepted simple c++ solution
Translated version from [zrythpzhl][1]'s Python solution. 

    class Solution {
    public:
        vector<vector<int>> palindromePairs(vector<string>& words) {
            vector<vector<int>> res;
            if (!words.size()) return res;
            unordered_map<string, size_t> word_idx;
            for (size_t i = 0; i < words.size(); ++i) {
                word_idx[words[i]] = i;
            }
            vector<int> slu(2);
            for (size_t i = 0; i < words.size(); ++i) {
                size_t len = words[i].length();
                for (size_t l = 0; l <= len; ++l) {
                    string left = words[i].substr(0, l);
                    string right = words[i].substr(l);
                    string rleft = left;
                    string rright = right;
                    reverse(rleft.begin(), rleft.end());
                    reverse(rright.begin(), rright.end());
                    if (word_idx.find(rleft) != word_idx.end()) {
                        if (word_idx[rleft] != i && isPalindrome(right)) {
                            slu[0] = i;
                            slu[1] = word_idx[rleft];
                            res.push_back(slu);                        
                        }
    
                    }
                    if (l != 0 && word_idx.find(rright) != word_idx.end()) {
                        if (word_idx[rright] != i && isPalindrome(left)) {
                            slu[0] = word_idx[rright];
                            slu[1] = i;
                            res.push_back(slu);                        
                        }
    
                    }
    
                }
            }
            return res;
        }
        
        bool isPalindrome(string s) {
            if (s.size() <= 1) return true;
            size_t i = 0; 
            size_t j = s.size() - 1;
            while (i < j) {
                if (s[i++] != s[j--]) return false;
            }
            
            return true;
        }
    };


  [1]: https://leetcode.com/discuss/91284/python-solution

----------------------------------------------------------------------------------------------------
11-line Python solution, easy to understand, mix all words + all reversed words then use common prefix
Sort all words and all reversed words. One word (call it `A`) is the prefix of the following words (call it `B`). If `A` is `B`'s prefix and one is reversed one is not, and their indexes are different, then we find a palindrome pair.

    def palindromePairs(self, words):
        # 0 means the word is not reversed, 1 means the word is reversed
        words, length, result = sorted([(w, 0, i, len(w)) for i, w in enumerate(words)] +
                                       [(w[::-1], 1, i, len(w)) for i, w in enumerate(words)]), len(words) * 2, []
        for i, (word1, rev1, ind1, len1) in enumerate(words):
            for j in xrange(i + 1, length):
                word2, rev2, ind2, _ = words[j]
                if word2.startswith(word1):
                    if ind1 != ind2 and rev1 ^ rev2:
                        rest = word2[len1:]
                        if rest == rest[::-1]: result += ([ind1, ind2],) if rev2 else ([ind2, ind1],)
                else:
                    break
        return result

----------------------------------------------------------------------------------------------------
Python Solution with Trie
My first post in discussion.  This idea is kind of hard to follow if you didn't try on the same way by yourself before.  Time complexity of current algorithm is not linear, but can be improved to guarantee linear even in worst case.  

Build a Trie with words.  When reach the end of the word, use "isword" to keep the index of the word.  During adding a word to the Trie, if the rest of the word is palin, add the index of the word to key "ids" of that node.

Then for each word, look for the reverse of the word in the Trie.  During searching for each word, if word ends but the trie path still continues, check the "ids" key of that node (node["ids"] keeps the index of the word which substring is palin after this node).

Check for empty string separately at last.

Current algorithm has a high worst case time complexity, but can be improved to guarantee O(n) (total number of characters of all words).  I used a KMP method to calculate the suffix palin for each word in O(len(word)), and also for each reverse word.  Therefore the ispalin can be check in O(1) after a linear preprocess for each word.  However, that solution went TLE.  The reason is: for the current algorithm, we don't need to do ispalin check for a good part of cases. However, for that preprocess method, we can't escape a linear preprocessing.   


class Solution(object):
    
    def ispalin(self, s):  # check if a string is palin (s is suffix of word in our case)
        return s == s[::-1]
    
    def palindromePairs(self, words):
        result = []
        root = {}  # use dict instead of a TrieNode class to save space
        for i, word in enumerate(words):
            curr = root
            for idx, ch in enumerate(word):
                if ch not in curr:
                    curr[ch] = {}
                curr = curr[ch]
                tmp = word[idx+1:]
                if tmp and self.ispalin(tmp):
                    # keep the idx of word if the suffix of the word after current position is palin
                    curr.setdefault("ids", []).append(i)
            curr["isword"] = i  # keep idx of word when reach the end
        for j, word in enumerate(words):  # start searching reverse of each word in the Trie
            w = word[::-1]
            curr = root
            fail = False
            for idx, ch in enumerate(w):
                if ch not in curr:
                    fail = True
                    break
                curr = curr[ch]
                # if current node is the end of some word, check whether the suffix of reverse word is palin
                i = curr.get("isword")
                if i is not None and i != j and self.ispalin(w[idx+1:]):
                    result.append([i, j])
            if not fail and "ids" in curr:
                result.extend([i, j] for i in curr["ids"] if i != j)
        if "" in words:  # check for "" case
            idx = words.index("")
            result.extend(reduce(lambda x, y: x + y, ([[i, idx], [idx, i]] for i, w in enumerate(words) if w and self.ispalin(w))))
        return result

----------------------------------------------------------------------------------------------------
Easy to understand Java code using HashMap
    public List<List<Integer>> palindromePairs(String[] words) {
    		List<List<Integer>> result = new ArrayList<>();
    		HashMap<String, Integer> hm = new HashMap<>();
    
    		// put all the words in HashMap for easy look-up
    		for (int i = 0; i < words.length; i++) {
    			hm.put(words[i], i);
    		}
    
    		for (int i = 0; i < words.length; i++) {
    			String reverse = new StringBuilder(words[i]).reverse().toString();
    
    			// check if there is reverse word present
    			if (hm.containsKey(reverse) && hm.get(reverse) != i) {
    				List<Integer> list = new ArrayList<>();
    				list.add(i);
    				list.add(hm.get(reverse));
    				result.add(list);
    			}
    
    			// check if there is empty string
    			// in that case if word is palindrome, empty string can be added
    			// before and after the word.
    			if (hm.containsKey("")
    					&& hm.get("") != i
    					&& new StringBuilder(words[i]).reverse().toString()
    							.equals(words[i])) {
    				List<Integer> list = new ArrayList<>();
    				list.add(i);
    				list.add(hm.get(""));
    				result.add(list);
    				list = new ArrayList<>();
    				list.add(hm.get(""));
    				list.add(i);
    				result.add(list);
    			}
    
    			// check if some other word can be added as prefix
    			int curReverse = 0;
    			while (curReverse < reverse.length() - 1) {
    				if (hm.containsKey(reverse.substring(0, curReverse + 1))) {
    					String rem = words[i].substring(0, words[i].length()
    							- curReverse - 1);
    					if (new StringBuilder(rem).reverse().toString().equals(rem)) {
    						List<Integer> list = new ArrayList<>();
    						list.add(hm.get(reverse.substring(0, curReverse + 1)));
    						list.add(i);
    						result.add(list);
    					}
    				}
    				curReverse++;
    			}
    
    			// check if some other word can be added as suffix
    			int curForward = 0;
    			while (curForward < words[i].length() - 1) {
    				String rev = new StringBuilder(words[i].substring(0,
    						curForward + 1)).reverse().toString();
    				if (hm.containsKey(rev)) {
    					String rem = words[i].substring(curForward + 1);
    					if (new StringBuilder(rem).reverse().toString().equals(rem)) {
    						List<Integer> list = new ArrayList<>();
    						list.add(i);
    						list.add(hm.get(rev));
    						result.add(list);
    					}
    				}
    				curForward++;
    			}
    		}
    		return result;
    	}

----------------------------------------------------------------------------------------------------
What does it matter, the length of words or the number of words. It&#x27;s not clear.
the description in this problem is not clear. Judging from the answer, the the number of words is huge, so the O(n*k^2) is ok. but what if the length of each word is also huge?

----------------------------------------------------------------------------------------------------
Why there was no time limit posted on this question
There was no time limit posted on this question
Is there a way the question posters also post the time limit along with problem

----------------------------------------------------------------------------------------------------
Concise Python Solution
    class Solution(object):
        def palindromePairs(self, words):
            """
            :type words: List[str]
            :rtype: List[List[int]]
            """
            res = []
            dic = {}
            for i in range(len(words)):
                dic[words[i]] = i
            for word in words:
                word_rev = word[::-1]
                if word_rev in dic and dic[word_rev] != dic[word]:
                    res.append([dic[word_rev], dic[word]])
                for i in range(len(word)):
                    temp1 = word[:i][::-1]
                    temp2 = word_rev[:i]
                    if temp1 in dic and isPal(word[i:]):
                        res.append([dic[word], dic[temp1]])
                    if temp2 in dic and isPal(word_rev[i:]):
                        res.append([ dic[temp2], dic[word]])
            return res
    def isPal(word):
        left = 0
        right = len(word)-1
        while left < right:
            if word[left] != word[right]:
                return False
            left += 1
            right -= 1
        return True
                        

----------------------------------------------------------------------------------------------------
107ms AC Java Solution-Time Complexity is O(N*K)--N is size of words, K is avg length of a word
    public List<List<Integer>> palindromePairs(String[] words) {
        List<List<Integer>> res =new ArrayList<>();
        if(words == null|| words.length <2)
        	return res;
        
        Map<String,Integer> word_idx = new HashMap<>();
        
        for( int i = 0 ; i< words.length ; i++)
        	word_idx.put(words[i], i);
        
		for (int i = 0; i < words.length; i++) {
			String aWord = words[i];
			if (aWord.length() > 0) {
				if (!isPalindrome(aWord, 0, aWord.length() - 1)) {

					String comple = reverseLetters(aWord, 0, aWord.length() - 1);

					if (word_idx.containsKey(comple)) {
						List<Integer> aCombo = new ArrayList<>();
						aCombo.add(i);
						aCombo.add(word_idx.get(comple));
						res.add(aCombo);
					}

				} else {
					String comple = "";
					if (word_idx.containsKey(comple)) {
						List<Integer> aCombo = new ArrayList<>();
						aCombo.add(i);
						aCombo.add(word_idx.get(comple));
						res.add(new ArrayList<Integer>(aCombo));
						aCombo.set(0, aCombo.set( 1,aCombo.get(0) ) );
						res.add(aCombo);
					}
				}

				for (int j = 0; j < aWord.length(); j++) {

					if (j + 1 < aWord.length() && isPalindrome(aWord, 0, j)) {
						String comple = reverseLetters(aWord, j + 1,
								aWord.length() - 1);

						if (word_idx.containsKey(comple)) {
							List<Integer> aCombo = new ArrayList<>();
							aCombo.add(word_idx.get(comple));
							aCombo.add(i);
							res.add(aCombo);
						}

					}

					if (0 < j && j < aWord.length()
							&& isPalindrome(aWord, j, aWord.length() - 1)) {

						String comple = reverseLetters(aWord, 0, j - 1);

						if (word_idx.containsKey(comple)) {
							List<Integer> aCombo = new ArrayList<>();
							aCombo.add(i);
							aCombo.add(word_idx.get(comple));
							res.add(aCombo);
						}

					}
				}
			}
        }
        
        return res;
    }
	
	private boolean isPalindrome(String aWord, int start, int end){
		
		if(end == start ) return true;
		
		int mid = (end+start+1)/2;
		
		for(int i = start ; i < mid ; i ++){
			if(aWord.charAt(i) != aWord.charAt(end+start-i))
				return false;
		}
		
		return true;
	}
	
	private String reverseLetters(String s , int start, int end){
		if(end == start) return String.valueOf(s.charAt(end));
		StringBuffer sb = new StringBuffer();
		
		for( int i = end ; i>= start ; i--)
			sb.append(s.charAt(i));
		
		return sb.toString();
	}

----------------------------------------------------------------------------------------------------
What is the time efficiency supposed to be?
My code is right in that it finds the correct indices, but I keep getting a "too long to execute" error. When I run the timing in my dev environment for their test case that fails, it take 675ms. Not extraordinary, but not bad either, so what gives? What are we aiming for, there is no feedback or definition at the beginning of the problem.

----------------------------------------------------------------------------------------------------
