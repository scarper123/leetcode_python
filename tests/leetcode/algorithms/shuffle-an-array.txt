Share my greedy solution
Many of the posts have the same algorithm. In short we can first solve 2 simpler problem

1. Create the maximum number of one array 
2. Create the maximum number of two array using all of their digits.

For an long and detailed explanation see my blog [here][1].

The algorithm is O((m+n)^3) in the worst case. It runs in 22 ms.

**Java**

    public int[] maxNumber(int[] nums1, int[] nums2, int k) {
        int n = nums1.length;
        int m = nums2.length;
        int[] ans = new int[k];
        for (int i = Math.max(0, k - m); i <= k && i <= n; ++i) {
            int[] candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i), k);
            if (greater(candidate, 0, ans, 0)) ans = candidate;
        }
        return ans;
    }
    private int[] merge(int[] nums1, int[] nums2, int k) {
        int[] ans = new int[k];
        for (int i = 0, j = 0, r = 0; r < k; ++r)
            ans[r] = greater(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];
        return ans;
    }
    public boolean greater(int[] nums1, int i, int[] nums2, int j) {
        while (i < nums1.length && j < nums2.length && nums1[i] == nums2[j]) {
            i++;
            j++;
        }
        return j == nums2.length || (i < nums1.length && nums1[i] > nums2[j]);
    }
    public int[] maxArray(int[] nums, int k) {
        int n = nums.length;
        int[] ans = new int[k];
        for (int i = 0, j = 0; i < n; ++i) {
            while (n - i + j > k && j > 0 && ans[j - 1] < nums[i]) j--;
            if (j < k) ans[j++] = nums[i];
        }
        return ans;
    }


  [1]: http://algobox.org/create-maximum-number/

----------------------------------------------------------------------------------------------------
C++ 16ms, FASTEST, beats 97%.
The basic idea:

To create max number of length k from two arrays, you need to create max number of length i from array one and max number of length k-i from array two, then combine them together. After trying all possible i, you will get the max number created from two arrays.

Optimization: 

1. Suppose nums1 = [3, 4, 6, 5], nums2 = [9, 1, 2, 5, 8, 3], the maximum number you can create from nums1 is [6, 5] with length 2. For nums2, it's [9, 8, 3] with length 3. Merging the two sequence, we have [9, 8, 6, 5, 3], which is the max number we can create from two arrays without length constraint. If the required length k<=5, we can simply trim the result to required length from front. For instance, if k=3, then [9, 8, 6] is the result. 

2. Suppose we need to create max number with length 2 from num = [4, 5, 3, 2, 1, 6, 0, 8]. The simple way is to use a stack, first we push 4 and have stack [4], then comes 5 > 4, we pop 4 and push 5, stack becomes [5], 3 < 5, we push 3, stack becomes [5, 3]. Now we have the required length 2, but we need to keep going through the array in case a larger number comes, 2 < 3, we discard it instead of pushing it because the stack already grows to required size 2. 1 < 3, we discard it. 6 > 3, we pop 3, since 6 > 5 and there are still elements left, we can continue to pop 5 and push 6, the stack becomes [6], since 0 < 6, we push 0, the stack becomes [6, 0], the stack grows to required length again. Since 8 > 0, we pop 0, although 8 > 6, we can't continue to pop 6 since there is only one number, which is 8, left, if we pop 6 and push 8, we can't get to length 2, so we push 8 directly, the stack becomes [6, 8]. 

3. In the basic idea, we mentioned trying all possible length i. If we create max number for different i from scratch each time, that would be a waste of time. Suppose num = [4, 9, 3, 2, 1, 8, 7, 6], we need to create max number with length from 1 to 8. For i==8, result is the original array. For i==7, we need to drop 1 number from array, since 9 > 4, we drop 4, the result is [9, 3, 2, 1, 8, 7, 6]. For i==6, we need to drop 1 more number, 3 < 9, skip, 2 < 3, skip, 1 < 2, skip, 8 > 1, we drop 1, the result is [9, 3, 2, 8, 7, 6]. For i==5, we need to drop 1 more, but this time, we needn't check from beginning, during last scan, we already know [9, 3, 2] is monotonically non-increasing, so we check 8 directly, since 8 > 2, we drop 2, the result is [9, 3, 8, 7, 6]. For i==4, we start with 8, 8 > 3, we drop 3, the result is [9, 8, 7, 6]. For i==3, we start with 8, 8 < 9, skip, 7 < 8, skip, 6 < 7, skip, by now, we've got maximum number we can create from num without length constraint. So from now on, we can drop a number from the end each time. The result is [9, 8, 7], For i==2, we drop last number 7 and have [9, 8]. For i==1, we drop last number 8 and have [9].

#

    class Solution {
    public:
        #define MIN(a,b) (a<b?a:b)
        #define MAX(a,b) (a>b?a:b)
        // create max number of length t from single non-empty vector
        void getMax(int* num, int& len, int* result, int& t, int& sortedLen)
        {
        	int n, top = 0;
        	result[0] = num[0];
        	const int need2drop = len - t;
        	for (int i = 1; i < len; ++i){
        		n = num[i];
        		while (top >= 0 && result[top] < n && (i - top) <= need2drop) --top; // i - top means already dropped i - top numbers
        		if (i - top > need2drop){
        			sortedLen = MAX(1,top);
        			while (++top < t) result[top] = num[i++];
        			return;
        		}
        		if (++top < t) result[top] = n;
        		else top = t - 1;
        	}
        }
        // create max number of different length from single vector
        void dp(int *num, int len, int&sortedLen, int& minL, int& maxL, int *res, int &k){
        	int  j, *head, *prevhead = res;
        	const int soi = sizeof(int);
        	getMax(num, len, res, maxL,sortedLen);
        	for (int l = maxL; l > MAX(minL,1); --l){
        		head = prevhead + k;
        		memcpy(head, prevhead, l*soi);
        		for (j = sortedLen; j < l; ++j){
        			if (head[j] > head[j - 1]){
        				sortedLen = MAX(1, j - 1);
        				memcpy(head + j - 1, prevhead + j, soi*(l - j));
        				break;
        			}
        		}
        		if (j == l) sortedLen = l;
        		prevhead = head;
        	}
        }
        // merge max number created from single vector
        void merge(int* num1,int len1,int* num2,int len2,int* result,int& resSize){
        	int i = 0, j = 0, k = 0;
        	while (i < resSize){
        		if (j < len1 && k < len2){
        			if (num1[j] > num2[k])
        				result[i++] = num1[j++];
        			else if (num1[j] < num2[k])
        				result[i++] = num2[k++];
        			else{
        				int remaining1 = len1 - j, remaining2 = len2 - k, tmp = num1[j];
        				int flag = memcmp(num1 + j, num2 + k, sizeof(int) * MIN(remaining1, remaining2));
        				flag = (flag == 0 ? (remaining1>remaining2 ? 1 : -1) : flag);
        				int * num = flag > 0 ? num1 : num2;
        				int & cnt = flag > 0 ? j : k;
        				int len = flag > 0 ? len1 : len2;
        				while (num[cnt]==tmp && cnt < len && i<resSize) result[i++] = num[cnt++];
        			}
        		}
        		else if (j < len1) result[i++] = num1[j++];
        		else result[i++] = num2[k++];
        	}
        }
        
        vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k){
        	int soi = sizeof(int), len1 = nums1.size(), len2 = nums2.size(), step = k*soi;
        	int minL1 = MAX(0, k - len2), maxL1 = MIN(k, len1), minL2 = k - maxL1, maxL2 = k - minL1, range = maxL1 - minL1 + 1;
        	int * res = new int[range * k * 2 + 2 * k], *dp1 = res + k, *dp2 = res + range*k+k, *tmp=res+range*2*k+k;
        	memset(res, 0, step);
        	int sortedLen1 = 1, sortedLen2 = 1;
        	if (len1 == 0 && len2 > 0) getMax(&nums2[0], len2, res, k, sortedLen2);
        	else if (len1 > 0 && len2 == 0) getMax(&nums1[0], len1, res, k, sortedLen2);
        	else if (len1 > 0 && len2 > 0){
        		dp(&nums1[0], len1, sortedLen1, minL1, maxL1, dp1,k);
        		dp(&nums2[0], len2, sortedLen2, minL2, maxL2, dp2,k);
        		if (sortedLen1 + sortedLen2 > k){
        			merge(dp1 + k*(maxL1 - sortedLen1), sortedLen1, dp2 + k*(maxL2 - sortedLen2), sortedLen2, tmp, k);
        			vector<int> resv(tmp, tmp + k);
        			delete[] res;
        			return resv;
        		}
        		for (int i = minL1; i <= maxL1; ++i){
        			merge(dp1+k*(maxL1-i), i, dp2+k*(maxL2-k+i), (k-i), tmp,k);
        			if (memcmp(res, tmp, step) < 0) memcpy(res, tmp, step);
        		}
        	}
        	vector<int> resv(res, res + k);
        	delete[] res;
        	return resv;
        }
    };

----------------------------------------------------------------------------------------------------
Short Python &#x2F; Ruby &#x2F; C++
**Python**

    def maxNumber(self, nums1, nums2, k):

        def prep(nums, k):
            drop = len(nums) - k
            out = []
            for num in nums:
                while drop and out and out[-1] < num:
                    out.pop()
                    drop -= 1
                out.append(num)
            return out[:k]

        def merge(a, b):
            return [max(a, b).pop(0) for _ in a+b]

        return max(merge(prep(nums1, i), prep(nums2, k-i))
                   for i in range(k+1)
                   if i <= len(nums1) and k-i <= len(nums2))

Solved it on my own but now I see others already posted this idea. Oh well, at least it's short, particularly my `merge` function.

The last two lines can be combined, but I find it rather ugly and not worth it:  
`for i in range(max(k-len(nums2), 0), min(k, len(nums1))+1))`

---

**Ruby**

    def prep(nums, k)
      drop = nums.size - k
      out = [9]
      nums.each do |num|
        while drop > 0 && out[-1] < num
          out.pop
          drop -= 1
        end
        out << num
      end
      out[1..k]
    end
    
    def max_number(nums1, nums2, k)
      ([k-nums2.size, 0].max .. [nums1.size, k].min).map { |k1|
        parts = [prep(nums1, k1), prep(nums2, k-k1)]
        (1..k).map { parts.max.shift }
      }.max
    end

---

**C++**

Translated it to C++ as well now. Not as short anymore, but still decent. And C++ allows different functions with the same name, so I chose to do that here to show how nicely the `maxNumber(nums1, nums2, k)` problem can be based on the problems `maxNumber(nums, k)` and `maxNumber(nums1, nums2)`, which would make fine problems on their own.

    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {
        int n1 = nums1.size(), n2 = nums2.size();
        vector<int> best;
        for (int k1=max(k-n2, 0); k1<=min(k, n1); ++k1)
            best = max(best, maxNumber(maxNumber(nums1, k1),
                                       maxNumber(nums2, k-k1)));
        return best;
    }

    vector<int> maxNumber(vector<int> nums, int k) {
        int drop = nums.size() - k;
        vector<int> out;
        for (int num : nums) {
            while (drop && out.size() && out.back() < num) {
                out.pop_back();
                drop--;
            }
            out.push_back(num);
        }
        out.resize(k);
        return out;
    }

    vector<int> maxNumber(vector<int> nums1, vector<int> nums2) {
        vector<int> out;
        while (nums1.size() + nums2.size()) {
            vector<int>& now = nums1 > nums2 ? nums1 : nums2;
            out.push_back(now[0]);
            now.erase(now.begin());
        }
        return out;
    }

An alternative for `maxNumber(nums1, nums2)`:

    vector<int> maxNumber(vector<int> nums1, vector<int> nums2) {
        vector<int> out;
        auto i1 = nums1.begin(), end1 = nums1.end();
        auto i2 = nums2.begin(), end2 = nums2.end();
        while (i1 != end1 || i2 != end2)
            out.push_back(lexicographical_compare(i1, end1, i2, end2) ? *i2++ : *i1++);
        return out;
    }

----------------------------------------------------------------------------------------------------
Share my 21ms java solution with comments
To find the maximum ,we can enumerate how digits we should get from nums1 , we suppose it is i.

So ,  the digits from nums2 is K - i.

And we can use a stack to get the get maximum number(x digits) from one array.

OK, Once we choose two maximum subarray , we should combine it to the answer.

It is just like merger sort, but we should pay attention to the case: the two digital are equal.

we should find the digits behind it to judge which digital we should choose now.

In other words,we should judge which subarry is bigger than the other.

That's all.

If you have any question or suggest, I am happy you can comment on my blog : [Create Maximum Number][1].

Thanks, merry christmas :)

 *update:use stack to find max sub array and it runs 21ms now.( thanks to @dietpepsi )*

   

     /**  * Created by hrwhisper on 2015/11/23.  * http://www.hrwhisper.me/leetcode-create-maximum-number/  */
    
    
    public class Solution {
        public int[] maxNumber(int[] nums1, int[] nums2, int k) {
            int get_from_nums1 = Math.min(nums1.length, k);
            int[] ans = new int[k];
            for (int i = Math.max(k - nums2.length, 0); i <= get_from_nums1; i++) {
                int[] res1 = new int[i];
                int[] res2 = new int[k - i];
                int[] res = new int[k];
                res1 = solve(nums1, i);
                res2 = solve(nums2, k - i);
                int pos1 = 0, pos2 = 0, tpos = 0;
                
                while (res1.length > 0 && res2.length > 0 && pos1 < res1.length && pos2 < res2.length) {
                    if (compare(res1, pos1, res2, pos2))
                        res[tpos++] = res1[pos1++];
                    else
                        res[tpos++] = res2[pos2++];
                }
                while (pos1 < res1.length)
                    res[tpos++] = res1[pos1++];
                while (pos2 < res2.length)
                    res[tpos++] = res2[pos2++];
    
                if (!compare(ans, 0, res, 0))
                    ans = res;
            }
    
            return ans;
        }
    
        public boolean compare(int[] nums1, int start1, int[] nums2, int start2) {
            for (; start1 < nums1.length && start2 < nums2.length; start1++, start2++) {
                if (nums1[start1] > nums2[start2]) return true;
                if (nums1[start1] < nums2[start2]) return false;
            }
            return start1 != nums1.length;
        }
    
        public int[] solve(int[] nums, int k) {
            int[] res = new int[k];
            int len = 0;
            for (int i = 0; i < nums.length; i++) {
                while (len > 0 && len + nums.length - i > k && res[len - 1] < nums[i]) {
                    len--;
                }
                if (len < k)
                    res[len++] = nums[i];
            }
            return res;
        } }


  [1]: http://www.hrwhisper.me/leetcode-create-maximum-number/

----------------------------------------------------------------------------------------------------
Share my Python solution with explanation
To create the max number from num1 and nums2 with k elements, we assume the final result combined by i numbers (denotes as **left**) from num1 and j numbers (denotes as **right**) from nums2, where i+j==k.

Obviously, left and right must be the maximum possible number in num1 and num2 respectively. i.e. num1 = [6,5,7,1] and i == 2, then left must be [7,1]. 

The final result is the maximum possible merge of all left and right. 

So there're 3 steps:

 1. **iterate i from 0 to k.**
 2. **find max number from num1, num2 by select i , k-i numbers, denotes as left, right**
 3. **find max merge of left, right**

function **maxSingleNumber** select i elements from num1 that is maximum. The idea find the max number one by one. i.e. assume nums [6,5,7,1,4,2], selects = 3.
1st digit: find max digit in [6,5,7,1], the last two digits [4, 2] can not be selected at this moment.
2nd digits: find max digit in [1,4], since we have already selects 7, we should consider elements after it, also, we should leave one element out.
3rd digits: only one left [2], we select it. and function output [7,4,2]

function **mergeMax**  find the maximum combination of left, and right. 


    class Solution(object):
    def maxNumber(self, nums1, nums2, k):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :type k: int
        :rtype: List[int]
        """
        n, m= len(nums1),len(nums2)
        ret = [0] * k
        for i in range(0, k+1):
            j = k - i
            if i > n or j > m: continue
            left = self.maxSingleNumber(nums1, i)
            right = self.maxSingleNumber(nums2, j)
            num = self.mergeMax(left, right)
            ret = max(num, ret)
        return ret


    def mergeMax(self, nums1, nums2):
        ans = []
        while nums1 or nums2:
            if nums1 > nums2:
                ans += nums1[0],
                nums1 = nums1[1:]
            else:
                ans += nums2[0],
                nums2 = nums2[1:]
        return ans

    def maxSingleNumber(self, nums, selects):
        n = len(nums)
        ret = [-1]
        if selects > n : return ret
        while selects > 0:
            start = ret[-1] + 1 #search start
            end = n-selects + 1 #search end
            ret.append( max(range(start, end), key = nums.__getitem__))
            selects -= 1
        ret = [nums[item] for item in ret[1:]]
        return ret

----------------------------------------------------------------------------------------------------
Clean and easy to understand C++ solution
    vector<int> maxVector(vector<int> nums, int k) {
        while (nums.size() > k) {
            int i = 0, n = nums.size();
            for (; i < n - 1; ++i) {
                if (nums[i] < nums[i + 1]) {
                    nums.erase(nums.begin() + i);
                    break;
                }
            }
            if (i == n - 1) nums.erase(nums.begin() + i);
        }
    
        return nums;
    }
    
    bool compare(vector<int> &nums1, int i, vector<int> &nums2, int j) {
        while (i < nums1.size() && j < nums2.size() && nums1[i] == nums2[j]) {
            ++i;
            ++j;
        }
        if (j == nums2.size()) return true;
        if (i < nums1.size() && nums1[i] > nums2[j]) return true;
        return false;
    }
    
    vector<int> merge(vector<int> &nums1, vector<int> &nums2, int k) {
        vector<int> res(k, 0);
        for (int i = 0, j = 0, r = 0; r < k; ++r) {
            res[r] = compare(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];
        }
    
        return res;
    }
    
    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {
        int m = nums1.size(), n = nums2.size();
        vector<int> res(k, 0);
    
        for (int i = max(0, k - n); i <= min(k, m); ++i) {
            auto v1 = maxVector(nums1, i);
            auto v2 = maxVector(nums2, k - i);
            auto tmp = merge(v1, v2, k);
            if (compare(tmp, 0, res, 0)) res = tmp;
        }
    
        return res;
    }

----------------------------------------------------------------------------------------------------
divide to three subproblem solution, beat 98%
public class Solution {
    public int[] maxNumber(int[] nums1, int[] nums2, int k) {
        int len1 = nums1.length;
        int len2 = nums2.length;
        int[] result = new int[k];
        if(len1+len2 < k) {
            return result;//bad case
        }else if(len1+len2 == k){
            result = mergeTwoArrays(nums1, nums2, k);//edge case
        }else{
            for (int i = 0; i <= k; i++) {
                if(i<=len1 && (k-i)<=len2){
                    int[] maxNumbers1 = maxNumberOfSingleArray(nums1, i);
                    int[] maxNumbers2 = maxNumberOfSingleArray(nums2, k - i);
                    int[] maxNumbers = mergeTwoArrays(maxNumbers1, maxNumbers2, k);
                    if (compareTwoArrays(maxNumbers, 0, result, 0)) result = maxNumbers;
                }
            }
        }
        return result;
    }
    
    private int[] mergeTwoArrays(int[] nums1, int[] nums2, int k) {
        int[] result = new int[k];
        int idx1 = 0, idx2 = 0;
        int idx = 0;
        while(idx < k){
            //check the two remain arrays to see which one is larger.
            if(compareTwoArrays(nums1, idx1, nums2, idx2)){
                result[idx] = nums1[idx1++];
            }else{
                result[idx] = nums2[idx2++];
            }
            idx++;
        }
        return result;
    }
    
    //get the largest k numbers when keeping the relative order
    private int[] maxNumberOfSingleArray(int[] nums, int k){
        int[] result = new int[k];
        if(k == 0) return result;

        int len = nums.length;
        int idx = 0;
        for(int i = 0; i < len; i++){
            while((len-i-1) + (idx+1) > k && idx>0 && nums[i] > result[idx-1]) idx--;
            if(idx < k) result[idx++] = nums[i];
        }
        return result;
    }
    
    //compare two arrays at the "start" index
    public boolean compareTwoArrays(int[] nums1, int startIdx1, int[] nums2, int startIdx2) {
        int len1 = nums1.length - startIdx1;
        if(len1 <= 0) return false;
        int len2 = nums2.length - startIdx2;
        if(len2 <= 0) return true;
        int len = Math.max(len1, len2);
        for (int i = 0; i< len; i++) {
        	int digit1 = startIdx1 + i < nums1.length ? nums1[startIdx1 + i] : 0;
        	int digit2 = startIdx2 + i < nums2.length ? nums2[startIdx2 + i] : 0;
        	if(digit1 != digit2){
        	    return digit1 > digit2;
        	}
        }
        return true;//equal, choose either one is ok
    }
}


----------------------------------------------------------------------------------------------------
Share C++ 72ms with simple comments
    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {
        const int size1 = nums1.size();
        const int size2 = nums2.size();
        if (size1 + size2 < k) return vector<int>();
        vector<int> res(k, 0);
        vector<vector<int>> dp1(k+1, vector<int>()), dp2(k+1, vector<int>());
        getDp(nums1, k, dp1);
        getDp(nums2, k, dp2);
        for (int i = 0; i <= min(k, size1); i++) {
            int j = k - i;
            vector<int> temp_res(k, 0);
            myMerge(dp1[i].begin(), dp1[i].end(), dp2[j].begin(), dp2[j].end(), temp_res.begin());
            if (j <= size2 && compareVector(temp_res, res)) {
                res = temp_res;
            }
        }
        return res;
    }
    
    template <class container>
    bool compareVector ( container vec1, container vec2)
        {
          typename container::iterator first1 = vec1.begin(), last1 = vec1.end();
          typename container::iterator first2 = vec2.begin(), last2 = vec2.end();
          while (first1 != last1 && first2 != last2) {
            if (*first1 > *first2)
              return true;
            else if (*first1 < *first2) return false;
            ++first1; ++first2;
          }
          if (first1 == last1) return false;
          else return true;
        }
        
    void getDp(vector<int> nums, int k, vector<vector<int>> &dp) {
          while (nums.size() > k) {
                int j = 0;
                for (; j < nums.size() - 1; ++j) {
                    if (nums[j] < nums[j + 1]) {
                        nums.erase(nums.begin() + j); 
                        break;
                    }
                }
                if (j == nums.size() - 1) nums.erase(nums.begin() + j); 
           }
           dp[nums.size()] = nums;
           const int size1 = nums.size();
           for (int i = k; i > 0; i--) {
            if (i >= size1) continue; 
            else {
                dp[i] = dp[i+1];
                int j = 0;
                const int size_dp = dp[i].size();
                for (; j < size_dp - 1; ++j) {
                    if (dp[i][j] < dp[i][j + 1]) {
                        dp[i].erase(dp[i].begin() + j); 
                        break;
                    }
                }
                if (j == size_dp - 1) dp[i].erase(dp[i].begin() + j); 
            }
            
        }
    }
    template <class InputIterator1, class InputIterator2, class OutputIterator>
    OutputIterator myMerge (InputIterator1 first1, InputIterator1 last1,
                        InputIterator2 first2, InputIterator2 last2,
                        OutputIterator result)
    {
      while (true) {
        if (first1==last1) return std::copy(first2,last2,result);
        if (first2==last2) return std::copy(first1,last1,result);
        if (*first2 > *first1) *result++ = *first2++;
        else if (*first2 < *first1) *result++ = *first1++;
        else { // *first1 == *first2
            auto pos1 = first1, pos2 = first2;
            while (true) {
                int f1 = (++pos1 != last1) ? *(pos1) : INT_MIN;
                int f2 = (++pos2 != last2) ? *(pos2) : INT_MIN;
                if (f1 > f2) { *result++ = *first1++; break;}
                else if (f1 < f2) {*result++ = *first2++; break;}
            }
        }
      }
    }

----------------------------------------------------------------------------------------------------
An Accepted Python Solution
This problem could be divided into 2 sub-problems:

1. **function getMax(nums, t):**

  get t numbers from list *nums* to form one single maximized sub-list, with relative orders preserved

2. **function merge(nums1, nums2):**

  merge *nums1* and *nums2* to form one single maximized list, with relative orders preserved

The final result could be solved by enumerate the length of sub-list *nums1* and *nums2*, and record the max merged list.

Python Code:

    class Solution(object):
        def maxNumber(self, nums1, nums2, k):
            """
            :type nums1: List[int]
            :type nums2: List[int]
            :type k: int
            :rtype: List[int]
            """
            def getMax(nums, t):
                ans = []
                size = len(nums)
                for x in range(size):
                    while ans and len(ans) + size - x > t and ans[-1] < nums[x]:
                        ans.pop()
                    if len(ans) < t:
                        ans += nums[x],
                return ans
    
            def merge(nums1, nums2):
                ans = []
                while nums1 or nums2:
                    if nums1 > nums2:
                        ans += nums1[0],
                        nums1 = nums1[1:]
                    else:
                        ans += nums2[0],
                        nums2 = nums2[1:]
                return ans
            
            len1, len2 = len(nums1), len(nums2)
            res = []
            for x in range(max(0, k - len2), min(k, len1) + 1):
                tmp = merge(getMax(nums1, x), getMax(nums2, k - x))
                res = max(tmp, res)
            return res

Ref: [http://bookshadow.com/weblog/2015/12/24/leetcode-create-maximum-number/][1]


  [1]: http://bookshadow.com/weblog/2015/12/24/leetcode-create-maximum-number/

----------------------------------------------------------------------------------------------------
Strictly O(NK) C++ Solution with detailed explanation
    class list1
    {
        vector<int> a;
        vector<vector<int>> f;
    public:
        list1() = delete;
        inline int size() {return a.size();}
        inline int next(int x,int d) {return f[x][d];}
        list1(vector<int>& a0)
        {
            a = a0;
            f = vector<vector<int>>(a0.size() + 1,vector<int>(10,INT_MAX));
            for (int i = 0;i<a0.size();i++)
            {
                f[i][a[i]] = i;
                for (int j = i-1;j>=0;j--)
                {
                    if (a[j] == a[i]) break;
                    f[j][a[i]] = i;
                }
            }
        }
    };
    
    //dmd for detect_max_digit
    // dmd(a,x,rem) -> (max_digit, pos) , where a[pos-1] == max_digit
    // list a , from x, need rem numbers, x not included.
        
    pair<int,int> dmd(list1& a,int x,int rem)
    {
        for (int d = 9;d >= 0;d--)
        {
            int pos = a.next(x,d);
            if (pos == INT_MAX) continue;
            if (a.size() - (pos + 1) >= rem)
            return make_pair(d,pos + 1);
        }
    }
    
    
    class Solution {
    public:
        vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {
            list1 a1 = list1(nums1);
            int N1 = nums1.size();
            list1 a2 = list1(nums2);
            int N2 = nums2.size();
            
            auto ret = vector<int>(k,0);
            auto f = vector<int>(N1 + 1,0); 
            //f[i] denote a1[0..i-1] need a2[0..f[i]-1] to reach the current maximal number, and can expand to length k
            // in other words, the state is : the number is current maximal and can be expanded, list1 begin with a1[i] and list2 with a2[f[i]] 
            for (int d = 1;d <= k;d++)
            {
                int maxDigit = -1;
                auto tmpf = vector<int>(N1 + 1,INT_MAX);
                for (int x = 0;x<=N1;x++)
                {
                    int y = f[x];
                    if (y == INT_MAX) continue;
                    auto m1 = dmd(a1,x,k-d-(N2-y)); 
                    auto m2 = dmd(a2,y,k-d-(N1-x));
                    maxDigit = max(maxDigit,m1.first);
                    maxDigit = max(maxDigit,m2.first);
                }
                ret[d-1] = maxDigit;
                for (int x = 0;x<=N1;x++)
                {
                    int y = f[x];
                    if (y == INT_MAX) continue;
                    auto m1 = dmd(a1,x,k-d-(N2-y));
                    if (m1.first == maxDigit)
                    tmpf[m1.second] = min(tmpf[m1.second],y);
                    auto m2 = dmd(a2,y,k-d-(N1-x));
                    if (m2.first == maxDigit)
                    tmpf[x] = min(tmpf[x],m2.second);
                }
                f = tmpf;
            }
            return ret;
        }
    };

Any Question is welcome and will be answered as soon as possible.
Detailed explanation is coming soon!
You may firstly read my code, it's quite easy to understand.

## Detailed Solution ##
Let a1,a2 be the two list from where we construct the maximal number.
Let N1,N2 denote the size of a1,a2.
We construct the maximal number digit by digit.

Suppose we are constructing the d-th digit(ret[0..d-1] is done)  and we have a set of states S = {(a1,b1),(a2,b2),...(a_N,b_N)},For each state (x,y) in S, it means we use a1[0..(x-1)] and a2[0..(y-1)] to construct ret[0..d-1] and a1[x..N1] and a2[y..N2] are avaliabe to construct the remaining digits.

In the iteration, we need to construct the d-th digit as well as the set S', that is from where we can construct the d+1-th digit.

For every state (x,y) in S, we use the function "dmd" to obtain the biggest d-th digit we can get from it. 
Let maxdigit = {max(dmd(x,y)[1])|(x,y) in S}, it is the d-th digit.

As we now the d-th digit,
We scan S again,
For every state (x,y) in S, we use the function "dmd" to obtain the (x',y) and (x,y') it extands to, 
if a1[x'-1] == maxdigit, we add (x',y) to S'.
if a2[y'-1] == maxdigit, we add (x,y') to S'.

Now we can construct the d+1-th digit from S', note that the size of S' is at most N1, for(x,y1) and (x,y2), y1 < y2, (x,y2) is needless to be recorded.

Finally I'd like to use an typical example to illustrate the process.

> a1 = [8,1] a2 = [8,9] k = 4
> 
> S = {(0,0)}

the first digit is 8,

> S' = {(0,1),(1,0)}

the second digit is 9, we construct it from (0,1)

>S'' = {(0,2)}

the remain digits are 8 and 1,
we finally reach 8981.


----------------------------------------------------------------------------------------------------
92ms cpp: try first biggest num, with index pre-process
The basic idea is to find the largest number in answer array's first position: try number from 9 to 0, firstly in nums1: if a number can be found, check if the left numbers (minus numbers before the found number) are sufficient for k.

If we can find a largest number in both nums1 and nums2, we should compare the two answers, and keep the bigger one.

A fast pre-process for above solution: for i-th element in array nums1, lowPos1[i][num] is the smallest index of num in range [i, nums1.size()-1]. Since we have this helper, we can use O(1) time to find if num exists in nums1 or nums2 from a given position.

An important special case: when nums1.size() + nums2.size() = k, which means we have to use all elements in both arrays to produce the k-length answer. In such case, set two pointers pointing to the beginning of two arrays. Move the pointer with bigger number. Tricky part is when two pointers point to a same value, in this case we detect the values in two arrays behind the two pointers; we move the two pointers together until we find the values are different or one array is ended. The pointer with bigger value should go first, and if one pointer gets to end of array, the other pointer should go first.


    class Solution {
    public:
        unordered_map<string, vector<int>> store;
        deque<vector<int>> lowPos1, lowPos2;
        int len1, len2;
        
        vector<int> get(int p1, int p2, int k, vector<int>& nums1, vector<int>& nums2) {
            vector<int> ans;
            if (k==0)
                return ans;
            
            char buf[50];
            sprintf(buf, "%d.%d.%d", p1, p2, k);
            string key = buf;
            if (store.find(key) != store.end())
                return store[key];
            
            int rest = nums1.size()-p1 + nums2.size()-p2;
            if (k==rest) {
                while (p1<len1 || p2<len2)
                {
                    if (p1==len1 || (p2<len2 && nums1[p1] < nums2[p2]))
                        ans.push_back(nums2[p2++]);
                    else if (p2==len2 || (p1<len1 && nums1[p1] > nums2[p2]))
                        ans.push_back(nums1[p1++]);
                    else {
                        int i=0;
                        while (p1+i<len1 && p2+i<len2) {
                            if (nums1[p1+i] != nums2[p2+i])
                                break;
                            i++;
                        }
                        if (p1+i==len1 || (p2+i<len2 && nums2[p2+i]>nums1[p1+i]))
                            ans.push_back(nums2[p2++]);
                        else
                            ans.push_back(nums1[p1++]);
                    }
                }
            }
            else
            {
                for (int i=9; i>=0; i--) 
                {
                    vector<int> ans1, ans2;
                    int j = p1==len1 ? -1 : lowPos1[p1][i];
                    if (j!=-1 && rest-(j-p1)-1 >= k-1)
                    {
                        ans1.push_back(i);
                        vector<int> temp = get(j+1, p2, k-1, nums1, nums2);
                        ans1.insert(ans1.end(), temp.begin(), temp.end());
                    }
                    
                    j = p2==len2 ? -1 : lowPos2[p2][i];
                    if (j!=-1 && rest-(j-p2)-1 >= k-1)
                    {
                        ans2.push_back(i);
                        vector<int> temp = get(p1, j+1, k-1, nums1, nums2);
                        ans2.insert(ans2.end(), temp.begin(), temp.end());
                    }
        
                    if (ans1.size() + ans2.size())
                    {
                        if (ans1.size() < ans2.size())
                            std::swap(ans1, ans2);
                        bool use1=true;
                        for (int i=0; i<min(ans1.size(), ans2.size()); i++)
                            if (ans2[i] != ans1[i]) {
                                use1 = ans1[i]>ans2[i];
                                break;
                            }
                        ans = use1 ? ans1 : ans2;
                        break;
                    }
                }
            }
            
            store[key] = ans;
            return ans;
        }
        
        void preProcess(deque<vector<int>>& lowPos, const vector<int>& nums) {
            lowPos.push_back(vector<int> (10, -1));
            for (int i=(int)nums.size()-1; i>=0; i--) {
                lowPos.push_front(lowPos.front());
                lowPos.front()[nums[i]] = i;
            }
            lowPos.pop_back();
        }
        
        vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {
            len1=nums1.size(), len2=nums2.size();
            preProcess(lowPos1, nums1);
            preProcess(lowPos2, nums2);
            
            return get(0, 0, k, nums1, nums2);
        }
    };

----------------------------------------------------------------------------------------------------
C++  implementation of the top voted answer without the compare function
    class Solution {
    private:
        //get the max k-length number of array nums ...
        vector<int> helper(vector<int>& nums, int k){
            int n=nums.size();
            int j=0; // the count of the stacked array 
            vector<int> result(k,0);
            for(int i=0; i<n; i++){
                //result[j-1] stores the top of the stack 
                while(j>0 && n-i+j>k && nums[i]>result[j-1])  j--;
                if(j<k) result[j++]=nums[i];
            }
            return result;
        }
        
        vector<int> merge(vector<int>& nums1, vector<int>& nums2, int k){
            vector<int> result(k, 0);
            ostringstream num_str1, num_str2;
            string str1, str2;
            for(auto num:nums1)  num_str1 << num;
            for(auto num:nums2)  num_str2 << num;
            str1=num_str1.str();
            str2=num_str2.str();
            for(int i=0, j=0, r=0; r<k; r++){
                result[r] = str1.substr(i).compare(str2.substr(j)) > 0 ? nums1[i++] : nums2[j++];
            }
            return result;
        }
        
    public:
        vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {
            int n=nums1.size(), m=nums2.size();
            vector<int> result(k, 0);
            string result_str;
            for(int i=max(0, k-m); i<=k && i<=n; i++){
                vector<int> sub_1 = helper(nums1, i);
                vector<int> sub_2 = helper(nums2, k-i);
                vector<int> candidate = merge(sub_1, sub_2, k);
                ostringstream str_c;
                for(auto number:candidate)  str_c << number;
                if(result_str=="" || str_c.str().compare(result_str) > 0 ){
                    result_str=str_c.str();
                    result=candidate;
                }
            }
            return result;
        }
    };

----------------------------------------------------------------------------------------------------
O(m*n*k) DP solution, TLE
Now I find there are O(max(m, n) * k) greedy solution from the posts. My first idea is DP. Let f(i,j,k) represent maximum number of length k generated from nums1[1:i] and nums2[1:j]. the formula is: f(i,j,k) = max{f(i-1,j,k), f(i,j-1,k), f(i-1,j,k-1) + [nums1[i]], f(i,j-1,k-1) + [nums2[j]] } The implementation is as follows,

        def maxNumber(self, nums1, nums2, k):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :type k: int
        :rtype: List[int]
        """
        m = len(nums1)
        n = len(nums2)
        if k > m + n or k <= 0:
            return []
        #kk = 0
        pre_dp = [[[] for _ in xrange(n + 1)] for __ in xrange(m + 1)]
        
        for kk in xrange(1, k + 1):
            #kk
            dp = [[[] for _ in xrange(n + 1)] for __ in xrange(m + 1)]
            #i >= kk, j = 0
            for i in xrange(kk, m + 1):
                dp[i][0] = max(pre_dp[i-1][0] + [nums1[i-1]], dp[i-1][0])
                
            #i = 0, j >= kk
            for j in xrange(kk, n + 1):
                dp[0][j] = max(pre_dp[0][j-1] + [nums2[j-1]], dp[0][j-1])
            
            #i > 0, j > 0
            for i in xrange(1, m + 1):
                for j in xrange(1, n + 1):
                    if i + j < kk:
                        continue
                    dp[i][j] = max(dp[i-1][j], \
                                    dp[i][j-1], \
                                    pre_dp[i-1][j] + [nums1[i-1]], \
                                    pre_dp[i][j-1] + [nums2[j-1]])
            pre_dp, dp = dp, pre_dp
        return pre_dp[m][n]


----------------------------------------------------------------------------------------------------
Java 17 ms O(n + m + k^2 or 3?) worst case merge with lazy computation
