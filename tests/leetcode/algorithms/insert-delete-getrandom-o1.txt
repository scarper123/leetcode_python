9ms  short Java BST solution get answer when building BST
Every node will maintain a val **sum** recording the total of number on it's left bottom side, **dup** counts the duplication. For example, [3, 2, 2, 6, 1], from back to beginning,we would have:

                    1(0, 1)
                         \
                         6(3, 1)
                         /
                       2(0, 2)
                           \
                            3(0, 1)

When we try to insert a number, the total number of smaller number would be **adding dup and sum of the nodes where we turn right**.
for example, if we insert 5, it should be inserted on the way down to the right of 3, the nodes where we turn right is 1(0,1), 2,(0,2), 3(0,1), so the answer should be (0 + 1)+(0 + 2)+ (0 + 1) = 4
 
if we insert 7, the right-turning nodes are 1(0,1), 6(3,1), so answer should be (0 + 1) + (3 + 1) = 5

    public class Solution {
        class Node {
            Node left, right;
            int val, sum, dup = 1;
            public Node(int v, int s) {
                val = v;
                sum = s;
            }
        }
        public List<Integer> countSmaller(int[] nums) {
            Integer[] ans = new Integer[nums.length];
            Node root = null;
            for (int i = nums.length - 1; i >= 0; i--) {
                root = insert(nums[i], root, ans, i, 0);
            }
            return Arrays.asList(ans);
        }
        private Node insert(int num, Node node, Integer[] ans, int i, int preSum) {
            if (node == null) {
                node = new Node(num, 0);
                ans[i] = preSum;
            } else if (node.val == num) {
                node.dup++;
                ans[i] = preSum + node.sum;
            } else if (node.val > num) {
                node.sum++;
                node.left = insert(num, node.left, ans, i, preSum);
            } else {
                node.right = insert(num, node.right, ans, i, preSum + node.dup + node.sum);
            }
            return node;
        }
    }

----------------------------------------------------------------------------------------------------
Mergesort solution
The smaller numbers on the right of a number are exactly those that jump from its right to its left during a stable sort. So I do mergesort with added tracking of those right-to-left jumps.

**Update, new version**

    def countSmaller(self, nums):
        def sort(enum):
            half = len(enum) / 2
            if half:
                left, right = sort(enum[:half]), sort(enum[half:])
                for i in range(len(enum))[::-1]:
                    if not right or left and left[-1][1] > right[-1][1]:
                        smaller[left[-1][0]] += len(right)
                        enum[i] = left.pop()
                    else:
                        enum[i] = right.pop()
            return enum
        smaller = [0] * len(nums)
        sort(list(enumerate(nums)))
        return smaller

---

**Old version**

    def countSmaller(self, nums):
        def sort(enum):
            half = len(enum) / 2
            if half:
                left, right = sort(enum[:half]), sort(enum[half:])
                m, n = len(left), len(right)
                i = j = 0
                while i < m or j < n:
                    if j == n or i < m and left[i][1] <= right[j][1]:
                        enum[i+j] = left[i]
                        smaller[left[i][0]] += j
                        i += 1
                    else:
                        enum[i+j] = right[j]
                        j += 1
            return enum
        smaller = [0] * len(nums)
        sort(list(enumerate(nums)))
        return smaller

----------------------------------------------------------------------------------------------------
My simple AC Java Binary Search code
Traverse from the back to the beginning of the array, maintain an sorted array of numbers have been visited. Use findIndex() to find the first element in the sorted array which is larger or equal to target number. For example, [5,2,3,6,1], when we reach 2, we have a sorted array[1,3,6], findIndex() returns 1, which is the index where 2 should be inserted and is also the number smaller than 2. Then we insert 2 into the sorted array to form [1,2,3,6].

    public List<Integer> countSmaller(int[] nums) {
        Integer[] ans = new Integer[nums.length];
        List<Integer> sorted = new ArrayList<Integer>();
        for (int i = nums.length - 1; i >= 0; i--) {
            int index = findIndex(sorted, nums[i]);
            ans[i] = index;
            sorted.add(index, nums[i]);
        }
        return Arrays.asList(ans);
    }
    private int findIndex(List<Integer> sorted, int target) {
        if (sorted.size() == 0) return 0;
        int start = 0;
        int end = sorted.size() - 1;
        if (sorted.get(end) < target) return end + 1;
        if (sorted.get(start) >= target) return 0;
        while (start + 1 < end) {
            int mid = start + (end - start) / 2;
            if (sorted.get(mid) < target) {
                start = mid + 1;
            } else {
                end = mid;
            }
        }
        if (sorted.get(start) >= target) return start;
        return end;
    }

Due to the O(n) complexity of ArrayList insertion, the total runtime complexity is not very fast, but anyway it got AC for around 53ms.

----------------------------------------------------------------------------------------------------
C++ O(nlogn)-Time O(n)-Space MergeSort Solution with Detail Explanation
MergeSort-based solution is a standard way to solve problems related to inverse numbers.

Here is an example to illustrate the general idea of MergeSort-based algorithm:

Now we want to consider an array

                6 4 1 8 7 5 2 9

First thing first, split the array into to subarrays:

                6 4 1 8
                7 5 2 9

and then calculate the inverse numbers within the group:

                      1 4(1) 6(1,4) 8
                      2 5(2) 7(2,5) 9

where the numbers in the parentheses are the numbers that should be counted when we calculate the inverse number.
Now we need to merge these two arrays into one sorted array. The first element to be put into the sorted destination array is the "1" in the first array.

     1                  4(1) 6(1,4) 8
                      2 5(2) 7(2,5) 9               merged elements in the 2nd array = ()

The second element to merge is the "2" in the second array:

     1 2                4(1) 6(1,4) 8
                        5(2) 7(2,5) 9               merged elements in the 2nd array = (2)


The third element to merge is the "4" in the first array:

     1 2 4(1,2)              6(1,4) 8
                        5(2) 7(2,5) 9               merged elements in the 2nd array = (2)

When we merge the "4(1)", we found that "4" is actually greater than all merged elements in the second array (i.e. [2]). Therefore, we also need to consider those elements. Therefore, the numbers in the parenthese of 2 become (1)+(2) = (1,2). Next step:

     1 2 4(1,2) 5(2)         6(1,4) 8
                             7(2,5) 9               merged elements in the 2nd array = (2,5)

Next (add the inverse number of element "6" by 2)

     1 2 4(1,2) 5(2) 6(1,4,2,5)     8
                             7(2,5) 9               merged elements in the 2nd array = (2,5)

So and so forth, finally reach
            
     1 2 4(1,2) 5(2) 6(1,4,2,5) 7(2,5) 8(2,5,7) 9
                                                    merged elements in the 2nd array = (2,5,7,9)

Additionally, when we need to count the inverse number, we do not need to record the exact elements, we only need to record the numbers. So, we can use a variable to record the number of "merged elements in the 2nd array" (for example, `semilen` in the code beneath) and the number of smaller elements of each element (for example, `results[idx]` in the code beneath).

-

**Complexities:**

- Time: O(n log n)

- Space: O(n)


-

**C++ Accepted Code:**

    class Solution {
    protected:
        void merge_countSmaller(vector<int>& indices, int first, int last, 
                                vector<int>& results, vector<int>& nums) {
            int count = last - first;
            if (count > 1) {
                int step = count / 2;
                int mid = first + step;
                merge_countSmaller(indices, first, mid, results, nums);
                merge_countSmaller(indices, mid, last, results, nums);
                vector<int> tmp;
                tmp.reserve(count);
                int idx1 = first;
                int idx2 = mid;
                int semicount = 0;
                while ((idx1 < mid) || (idx2 < last)) {
                    if ((idx2 == last) || ((idx1 < mid) &&
                           (nums[indices[idx1]] <= nums[indices[idx2]]))) {
    					tmp.push_back(indices[idx1]);
                        results[indices[idx1]] += semicount;
                        ++idx1;
                    } else {
    					tmp.push_back(indices[idx2]);
                        ++semicount;
                        ++idx2;
                    }
                }
                move(tmp.begin(), tmp.end(), indices.begin()+first);
            }
        }
    public:
        vector<int> countSmaller(vector<int>& nums) {
            int n = nums.size();
            vector<int> results(n, 0);
            vector<int> indices(n, 0);
            iota(indices.begin(), indices.end(), 0);
            merge_countSmaller(indices, 0, n, results, nums);
            return results;
        }
    };




----------------------------------------------------------------------------------------------------
11ms JAVA solution using merge sort with explanation
The basic idea is to do merge sort to nums[]. To record the result, we need to keep the index of each number in the original array. So instead of sort the number in nums, we sort the indexes of each number. 
Example: nums = [5,2,6,1],  indexes = [0,1,2,3]
                After sort:             indexes = [3,1,0,2]

While doing the merge part, say that we are merging left[] and right[], left[] and right[] are already sorted.

We keep a **rightcount** to record how many numbers from right[] we have added and keep an array **count[]** to record the result.

When we move a number from right[] into the new sorted array, we increase rightcount by 1.

When we move a number from left[] into the new sorted array, we increase count[ index of the number ] by **rightcount**.



    int[] count;
    public List<Integer> countSmaller(int[] nums) {
        List<Integer> res = new ArrayList<Integer>();     

        count = new int[nums.length];
        int[] indexes = new int[nums.length];
        for(int i = 0; i < nums.length; i++){
        	indexes[i] = i;
        }
        mergesort(nums, indexes, 0, nums.length - 1);
        for(int i = 0; i < count.length; i++){
        	res.add(count[i]);
        }
        return res;
    }
    private void mergesort(int[] nums, int[] indexes, int start, int end){
    	if(end <= start){
    		return;
    	}
    	int mid = (start + end) / 2;
    	mergesort(nums, indexes, start, mid);
    	mergesort(nums, indexes, mid + 1, end);
    	
    	merge(nums, indexes, start, end);
    }
    private void merge(int[] nums, int[] indexes, int start, int end){
    	int mid = (start + end) / 2;
    	int left_index = start;
    	int right_index = mid+1;
    	int rightcount = 0;    	
    	int[] new_indexes = new int[end - start + 1];

    	int sort_index = 0;
    	while(left_index <= mid && right_index <= end){
    		if(nums[indexes[right_index]] < nums[indexes[left_index]]){
    			new_indexes[sort_index] = indexes[right_index];
    			rightcount++;
    			right_index++;
    		}else{
    			new_indexes[sort_index] = indexes[left_index];
    			count[indexes[left_index]] += rightcount;
    			left_index++;
    		}
    		sort_index++;
    	}
    	while(left_index <= mid){
			new_indexes[sort_index] = indexes[left_index];
    		count[indexes[left_index]] += rightcount;
    		left_index++;
    		sort_index++;
    	}
    	while(right_index <= end){
			new_indexes[sort_index++] = indexes[right_index++];
    	}
    	for(int i = start; i <= end; i++){
    		indexes[i] = new_indexes[i - start];
    	}
    }



----------------------------------------------------------------------------------------------------
Easiest Java solution
Traverse from `nums[len - 1]` to `nums[0]`,  and build a binary search tree, which stores:

1. `val`: value of `nums[i]`
2. `count`: if `val == root.val`, there will be `count` number of smaller numbers on the right

Run time is `10ms`. Hope it helps!

    public class Solution {
    	public List<Integer> countSmaller(int[] nums) {
    		List<Integer> res = new ArrayList<>();
    		if(nums == null || nums.length == 0) return res;
    		TreeNode root = new TreeNode(nums[nums.length - 1]);
    		res.add(0);
    		for(int i = nums.length - 2; i >= 0; i--) {
    			int count = insertNode(root, nums[i]);
    			res.add(count);
    		}
    		Collections.reverse(res);
    		return res;
    	}
    
    	public int insertNode(TreeNode root, int val) {
    		int thisCount = 0;
    		while(true) {
    			if(val <= root.val) {
    				root.count++;
    				if(root.left == null) {
    					root.left = new TreeNode(val); break;
    				} else {
    					root = root.left;
    				}
    			} else {
    				thisCount += root.count;
    				if(root.right == null) {
    					root.right = new TreeNode(val); break;
    				} else {
    					root = root.right;
    				}
    			}
    		}
    		return thisCount;
    	}
    }
    
    class TreeNode {
    	TreeNode left; 
    	TreeNode right;
    	int val;
    	int count = 1;
    	public TreeNode(int val) {
    		this.val = val;
    	}
    }

----------------------------------------------------------------------------------------------------
Short Java Binary Index Tree BEAT 97.33% With Detailed Explanation
This is the Binary Index Tree.

Here is a very good explanation. 

 [What is Binary Index Tree ][1]

The basic idea is:

    1, we should build an array with the length equals to the max element of the nums array as BIT.
    2, To avoid minus value in the array, we should first add the (min+1) for every elements 
    (It may be out of range, where we can use long to build another array. But no such case in the test cases so far.)
    3, Using standard BIT operation to solve it.

Here is the code, welcome to judge me:


    public class Solution {
        public List<Integer> countSmaller(int[] nums) {
            List<Integer> res = new LinkedList<Integer>();
            if (nums == null || nums.length == 0) {
                return res;
            }
            // find min value and minus min by each elements, plus 1 to avoid 0 element
            int min = Integer.MAX_VALUE;
            int max = Integer.MIN_VALUE;
            for (int i = 0; i < nums.length; i++) {
                min = (nums[i] < min) ? nums[i]:min;
            }
            int[] nums2 = new int[nums.length];
            for (int i = 0; i < nums.length; i++) {
                nums2[i] = nums[i] - min + 1;
                max = Math.max(nums2[i],max);
            }
            int[] tree = new int[max+1];
            for (int i = nums2.length-1; i >= 0; i--) {
                res.add(0,get(nums2[i]-1,tree));
                update(nums2[i],tree);
            }
            return res;
        }
        private int get(int i, int[] tree) {
            int num = 0;
            while (i > 0) {
                num +=tree[i];
                i -= i&(-i);
            }
            return num;
        }
        private void update(int i, int[] tree) {
            while (i < tree.length) {
                tree[i] ++;
                i += i & (-i);
            }
        }
    }

  [1]: https://www.topcoder.com/community/data-science/data-science-tutorials/binary-indexed-trees/

----------------------------------------------------------------------------------------------------
3 ways (Segment Tree, Binary Indexed Tree, Binary Search Tree) clean python code
**Segment Tree**

    class SegmentTreeNode(object):
        def __init__(self, val, start, end):
            self.val = val
            self.start = start
            self.end = end
            self.children = []
    
    
    class SegmentTree(object):
        def __init__(self, n):
            self.root = self.build(0, n - 1)
    
        def build(self, start, end):
            if start > end:
                return
    
            root = SegmentTreeNode(0, start, end)
            if start == end:
                return root
    
            mid = start + end >> 1
            root.children = filter(None, [
                self.build(start, end)
                for start, end in ((start, mid), (mid + 1, end))])
            return root
    
        def update(self, i, val, root=None):
            root = root or self.root
            if i < root.start or i > root.end:
                return root.val
    
            if i == root.start == root.end:
                root.val += val
                return root.val
    
            root.val = sum([self.update(i, val, c) for c in root.children])
            return root.val
    
        def sum(self, start, end, root=None):
            root = root or self.root
            if end < root.start or start > root.end:
                return 0
    
            if start <= root.start and end >= root.end:
                return root.val
    
            return sum([self.sum(start, end, c) for c in root.children])
    
    
    class Solution(object):
        def countSmaller(self, nums):
            hashTable = {v: i for i, v in enumerate(sorted(set(nums)))}
    
            tree, r = SegmentTree(len(hashTable)), []
            for i in xrange(len(nums) - 1, -1, -1):
                r.append(tree.sum(0, hashTable[nums[i]] - 1))
                tree.update(hashTable[nums[i]], 1)
            return r[::-1]
    

**Binary Indexed Tree** 


    class BinaryIndexedTree(object):
        def __init__(self, n):
            self.sums = [0] * (n + 1)
    
        def update(self, i, val):
            while i < len(self.sums):
                self.sums[i] += 1
                i += i & -i
    
        def sum(self, i):
            r = 0
            while i > 0:
                r += self.sums[i]
                i -= i & -i
            return r
    
    
    class Solution(object):
        def countSmaller(self, nums):
            hashTable = {v: i for i, v in enumerate(sorted(set(nums)))}
    
            tree, r = BinaryIndexedTree(len(hashTable)), []
            for i in xrange(len(nums) - 1, -1, -1):
                r.append(tree.sum(hashTable[nums[i]]))
                tree.update(hashTable[nums[i]] + 1, 1)
            return r[::-1]


**Binary Search Tree**    


    class BinarySearchTreeNode(object):
        def __init__(self, val):
            self.val = val
            self.left = None
            self.right = None
            self.count = 1
            self.leftTreeSize = 0
    
    
    class BinarySearchTree(object):
        def __init__(self):
            self.root = None
    
        def insert(self, val, root):
            if not root:
                self.root = BinarySearchTreeNode(val)
                return 0
    
            if val == root.val:
                root.count += 1
                return root.leftTreeSize
    
            if val < root.val:
                root.leftTreeSize += 1

                if not root.left:
                    root.left = BinarySearchTreeNode(val)
                    return 0
                return self.insert(val, root.left)
    
            if not root.right:
                root.right = BinarySearchTreeNode(val)
                return root.count + root.leftTreeSize
    
            return root.count + root.leftTreeSize + self.insert(
                val, root.right)
    
    
    class Solution(object):
        def countSmaller(self, nums):
            tree = BinarySearchTree()
            return [
                tree.insert(nums[i], tree.root)
                for i in xrange(len(nums) - 1, -1, -1)
            ][::-1]



----------------------------------------------------------------------------------------------------
C++ short solution using binary indexed tree (56 ms)


    class Solution {
    public:
        vector<int> countSmaller(vector<int>& nums) {
            vector<int> ret, clone = nums;;
            int len = (int) nums.size();
            unordered_map<int, int> reflect;
            array.resize(len + 1);
            sort(clone.begin(), clone.end());
            for (int i = 0; i < len; ++ i)
                reflect[clone[i]] = i + 1;
            
            for (int i = len - 1; i >= 0; -- i) {
                clone[i] = query(reflect[nums[i]] - 1);
                add(reflect[nums[i]], 1);
            }
            return clone;
        }
        
    private:
        vector<int> array;
        inline int lowbit(int pos) {
            return pos & -pos;
        }
        void add(int pos, int val) {
            long len = array.size();
            while (pos < len) {
                array[pos] += val;
                pos += lowbit(pos);
            }
        }
        int query(int pos) {
            int ret = 0;
            while (pos > 0) {
                ret += array[pos];
                pos -= lowbit(pos);
            }
            return ret;
        }
    };



----------------------------------------------------------------------------------------------------
O(NlogN) divide and conquer java solution based on bit by bit comparison
Before I actually get into the solution, let me first ask the question: given two integers, how would you determine which one is larger and which is smaller? 

Oh, you would say, use the built-in relational operators that come with the programming languages. True, it will give you the right answer, at a relatively higher level. But now imagine you were the computer, how would you actually do the comparison? **Remember now all you can see are two series of binary bits representing the two integers**. You have no better ways but start from the most significant bit and check bit by bit towards the least significant bit. The first bit will tell you the sign of the two numbers and you know positive numbers (with sign bit value of 0) will be greater than negative numbers (with sign bit value 1). If they have the same sign, then you continue to the next bit with the idea in mind that numbers with bit value 1 will be greater than those with bit value 0. You compare the two series of binary bits in this manner until at some point you can distinguish them or end up with no more bits to check(means the two integers are equal). 

What if we have an array of integers? It doesn't matter. We can proceed in the same way. First check the sign of each integer and partition them into two groups: positive integers and negative ones. Then for each group, we partition the integers further into two groups depending on the next-bit value: those with bit value 1 and those with bit value 0 (To unify sign partition and other bits partition, we will call the two groups after every partition as "highGroup" and "lowGroup" to indicate that all the integers in the highGroup will be greater than those in the lowGroup). And so on until we either have no numbers to partition or no bits to check. (Here we assume the integers have finite length of bits)

Now let's turn to our problem: for each integer in an array, count the number of integers to its right that are smaller than it. Based on the analysis above, we divide the integers into highGroup and lowGroup according to either the sign bit or other-bits. Since for each integer in the array, we only care about integers to its right, it would be better if we do the partition from right to left of the array. For each integer in the highGroup currently being checked, we know it will be greater than all those in the lowGroup accumulated so far. We proceed in this fashion until either the group is empty or have no more bits to check.

Notes: 

 1. To unify sign bit partition and other-bits partition, we used a variable called "highBit" to distinguish these two cases.
 2. we store the indices of the elements instead of the elements themselves as it's easier to set the results;
 3. I reversed the order of the elements when adding them to the list due to list performance consideration.

The time complexity can be analyzed as follows:

Let T(n) be the total run time and after the partition, we have b*n number in one group and (1-b)*n in the other with 0 <= b <= 1. Now the original problem is divided into two smaller subproblems with size given by b*n and (1-b)*n. And the solution to the original problem can be obtained by combining the solutions to the two subproblems in O(n) time, then we have:  

T(n) = T(b*n) + T((1-b)*n) + O(n) 

The solution to the characteristic equation b^x + (1-b)^x = 1 is x = 1 so the runtime complexity will be O(nlogn) according to the master theorem (one tricky scenario is b = 0 or b = 1. In this case the runtime is essentially linear provided the total number of bits in each integer is constant). By the way the space complexity is apparently O(n) due to the partition.

**Update**: The time complexity analysis above is based on the assumption that the number of partition is logarithmically dependent on the input array size, which is not the case for this problem. The number of partition is constant provided the integer bit size is constant (See @**StefanPochmann**'s answer below). 
Therefore O(nlogn) is a relaxed upper bound while the algorithm can run in linear time.

Here is the complete Java program:


    public List<Integer> countSmaller(int[] nums) {
        List<Integer> res = new ArrayList<>(nums.length);
        List<Integer> index = new ArrayList<>(nums.length);
        
        for (int i = nums.length - 1; i >= 0; i--) {
        	res.add(0);
        	index.add(i);
        }

        countSmallerSub(nums, index, 1 << 31, res);

        return res;
    }

    private void countSmallerSub(int[] nums, List<Integer> index, int mask, List<Integer> res) {
    	if (mask != 0 && index.size() > 1) {
        	List<Integer> highGroup = new ArrayList<>(index.size());
        	List<Integer> lowGroup = new ArrayList<>(index.size());

        	int highBit = (mask < 0 ? 0 : mask);
        	
        	for (int i = 0; i < index.size(); i++) {
        		if ((nums[index.get(i)] & mask) == highBit) {
        			res.set(index.get(i), res.get(index.get(i)) + lowGroup.size());
        			highGroup.add(index.get(i));
        		} else {
        			lowGroup.add(index.get(i));
        		}
        	}

        	countSmallerSub(nums, lowGroup, mask >>> 1, res);
        	countSmallerSub(nums, highGroup, mask >>> 1, res);
    	}
    }

----------------------------------------------------------------------------------------------------
C++ 14 line solution
    class Solution {
    public:
        vector<int> countSmaller(vector<int>& nums) {
            vector<int> db;
            vector<int> result(nums.size());
            for(int i = nums.size()-1; i >= 0; i--)
            {
                auto it = lower_bound(db.begin(), db.end(), nums[i]);
                result[i] = it - db.begin();
                db.insert(it, nums[i]);
            }
            return result;
        }
    };

----------------------------------------------------------------------------------------------------
Insert sort method C++ use 68ms solution
     vector<int> countSmaller(vector<int>& nums) {
        int size = nums.size();
        vector<int> res;
        vector<int> temp;
        for(int i=size-1;i>=0;--i){
            res.push_back(insert(temp,nums[i]));
        }
        reverse(res.begin(),res.end());
        return res; 
    }
    int insert(vector<int>& temp,int num){
        int size = temp.size();
        int res=distance(temp.begin(),lower_bound(temp.begin(),temp.end(),num));
        temp.insert(temp.begin()+res,num);
        return res;
        
    }

----------------------------------------------------------------------------------------------------
C++ 36ms BST solution.
The insert function will return the total number of nums smaller than x, and also put x in the right place.

    struct node{
        int val,copy,leftCnt;
        node *left,*right;
        node(int x){val=x;copy=1;leftCnt=0;left=NULL;right=NULL;}
    };

    int insert(node* root,int x){
        if (root->val==x){
            root->copy++;
            return root->leftCnt;
        }else if (root->val>x){
            root->leftCnt++;
            if (root->left==NULL) {
                root->left = new node(x);
                return 0;
            }else  return insert(root->left,x);
        }else{
            if (root->right==NULL){
                root->right = new node(x);
                return root->leftCnt+root->copy;
            }else return root->leftCnt+root->copy+insert(root->right,x);
        }
    }

    class Solution {
    public:
    vector<int> countSmaller(vector<int>& nums) {
        int sz=nums.size();
        vector<int> res(sz,0);
        if (sz<=1) return res;
        node *root = new node(nums[sz-1]);
        for (int i=sz-2;i>=0;i--){
            res[i] = insert(root,nums[i]);
        }
        return res;
    }
    };

----------------------------------------------------------------------------------------------------
Complicated segmentree solution, hope to find a better one
    public class Solution {
        static class segmentTreeNode {
            int start, end, count;
            segmentTreeNode left, right;
            segmentTreeNode(int start, int end, int count) {
                this.start = start;
                this.end = end;
                this.count = count;
                left = null;
                right = null;
            }
        }
        public static List<Integer> countSmaller(int[] nums) {
            // write your code here
            List<Integer> result = new ArrayList<Integer>();
            
            int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;
            for (int i : nums) {
                min = Math.min(min, i);
                
            }
            if (min < 0) {
                for (int i = 0; i < nums.length; i++) {
                    nums[i] -= min;//deal with negative numbers, seems a dummy way
                }
            }
            for (int i : nums) {
                max = Math.max(max, i);
            }
            segmentTreeNode root = build(0, max);
            for (int i = 0; i < nums.length; i++) {
                updateAdd(root, nums[i]);
            }
            for (int i = 0; i < nums.length; i++) {
                updateDel(root, nums[i]);
                result.add(query(root, 0, nums[i] - 1));
            }
            return result;
        }
        public static segmentTreeNode build(int start, int end) {
            if (start > end) return null;
            if (start == end) return new segmentTreeNode(start, end, 0);
            int mid = (start + end) / 2;
            segmentTreeNode root = new segmentTreeNode(start, end, 0);
            root.left = build(start, mid);
            root.right = build(mid + 1, end);
            root.count = root.left.count + root.right.count;
            return root;
        }
    
        public static int query(segmentTreeNode root, int start, int end) {
            if (root == null) return 0;
            if (root.start == start && root.end == end) return root.count;
            int mid = (root.start + root.end) / 2;
            if (end < mid) {
                return query(root.left, start, end);
            } else if (start > end) {
                return query(root.right, start, end);
            } else {
                return query(root.left, start, mid) + query(root.right, mid + 1, end);
            }
        }
    
        public static void updateAdd(segmentTreeNode root, int val) {
            if (root == null || root.start > val || root.end < val) return;
            if (root.start == val && root.end == val) {
                root.count ++;
                return;
            }
            int mid = (root.start + root.end) / 2;
            if (val <= mid) {
                updateAdd(root.left, val);
            } else {
                updateAdd(root.right, val);
            }
            root.count = root.left.count + root.right.count;
        }
    
        public static void updateDel(segmentTreeNode root, int val) {
            if (root == null || root.start > val || root.end < val) return;
            if (root.start == val && root.end == val) {
                root.count --;
                return;
            }
            int mid = (root.start + root.end) / 2;
            if (val <= mid) {
                updateDel(root.left, val);
            } else {
                updateDel(root.right, val);
            }
            root.count = root.left.count + root.right.count;
        }
    }

----------------------------------------------------------------------------------------------------
Nlogn Python solution, binary indexed tree, 160 ms
First get `rank`, the smallest number will be rank 1, the second smallest will be rank 2...With this `rank` info [binary indexed tree][1] can be used to count smaller numbers as we scan from right to left.

    def countSmaller(self, nums):
        rank, N, res = {val: i + 1 for i, val in enumerate(sorted(nums))}, len(nums), []
        BITree = [0] * (N + 1)
        
        def update(i):
            while i <= N:
                BITree[i] += 1
                i += (i & -i)
            
        def getSum(i):
            s = 0
            while i:
                s += BITree[i]
                i -= (i & -i)
            return s
        
        for x in reversed(nums):
            res += getSum(rank[x] - 1),
            update(rank[x])
        return res[::-1]


  [1]: https://en.wikipedia.org/wiki/Fenwick_tree

----------------------------------------------------------------------------------------------------
172ms Python BITree solution beats 99.07%
The problem is equal to find each number's inversion count. Actually there are three kinds of solutions: BST, mergeSort, and BITree. While the first two answer's time complexity is O(n*logn), and BITree time comlexity is O( n*log(maximumNum) ).

[Looking for what is BITree?][1] 

Actually we use the BITree to trace the total count of each position from [0-maximum] like a RadixSort. When we at index i, we want to find the smaller num's total count in range [i+1, n-1]. First, we find the maximum num in the array, and create a BITree length(maximum). After init, we could iterate the array from n-1 to 0, each time we could find the smaller num's total count using the BITree's sumRange function, add one to the num[i] position using BITree's update function. Each operation is O(log(maximum)), thus the total complexity will be O( n*log(maximumNum) ).

Well, in this problem, there might be minus numbers in the array, we could add a padding num which equal to the minimum number in the array.

Finally the code:

    class Solution(object):
        
        def getSum(self, T, idx):
            ans = 0
            while idx:
                ans += T[idx]
                idx -= idx & (-idx)
            return ans
        
        def update(self, T, idx, val):
            while idx <= len(T)-1:
                T[idx] += val
                idx += idx & (-idx)
    
        def countSmaller(self, nums):
            """
            :type nums: List[int]
            :rtype: List[int]
            """
            if not nums:
                return []
            n = len(nums)
            padding = min(nums)
            if padding <= 0:
                nums = [a + 1 - padding for a in nums]
            m = max(nums)
            T = [0] * (m+1)
            ans = []
            t = 0
            for num in nums[::-1]:
                ans.append(self.getSum(T, num-1))
                self.update(T, num, 1)
            return ans[::-1]




BTW: This is my first time answer a question, and wish my poor English could explain that clearly. I'll be glad to receive your reply which including any grammar problem either. ^_^

  [1]: http://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/

----------------------------------------------------------------------------------------------------
C++ easy 15 lines solution
    class Solution {
    public:
        vector<int> countSmaller(vector<int>& nums) {
            if (nums.empty()) return {};
            vector<int> hash;
            vector<int> counts(nums.size());
            for (int i = nums.size() - 1; i >= 0; --i)
            {
                auto end = lower_bound(hash.begin(), hash.end(), nums[i]);
                counts[i] = end - hash.begin();
                hash.insert(end, nums[i]);
            }
            return counts;
        }
    };

----------------------------------------------------------------------------------------------------
Missing test case &#91;2147483647,-2147483648&#93; for large range numbers
The test case [2147483647,-2147483648] should be added for the solution using segment tree. The tree size could be really large if not optimized properly.

If this test case is not expected to pass, then we need to update the description to limit the input numbers in a given range.

----------------------------------------------------------------------------------------------------
Share my AC BST solution
Store extra info leftSize and selfSize in the treeNode.
And add the nodes to the tree using the reverse order of the array
So, all the numbers after it self will be store in the tree before it.
Remember using the selfSize to deal with duplicates.

    public class Node {
            Node left;
            Node right;
            int val;
            int leftSize;
            int selfSize;
            public Node(int val) {
                this.val = val;
                selfSize = 1;
            }
        }
        public List<Integer> countSmaller(int[] nums) {
            List<Integer> list = new LinkedList<>();
            int n = nums.length;
            if (n == 0) {
                return list;
            }
            Node root = new Node(nums[n - 1]);
            list.add(0);
            for (int i = n - 2; i >= 0; i--) {
                list.add(0, addToTree(root, nums[i])); // add to the front of list
            }
            return list;
        }
        
        private int addToTree(Node root, int val) {
            int num = 0; // store the count less than it
            Node current = root;
            while (true) {
                if (current.val < val) {
                    num += current.leftSize + current.selfSize;
                    if (current.right == null) {
                        current.right = new Node(val);
                        break;
                    }
                    current = current.right;
                } else if (current.val > val) {
                    current.leftSize++; // remember to update the path nodes info
                    if (current.left == null) {
                        current.left = new Node(val);
                        break;
                    }
                    current = current.left;
                } else {
                    current.selfSize++; // duplicates
                    num += current.leftSize;
                    break;
                }
            }
            return num;
        }

----------------------------------------------------------------------------------------------------
14-line 44ms c++, building BST
    class Solution {
    public:
        struct Node {
            int val, smaller;
            Node *left, *right;
            Node(int value, int small) { 
                left=right=NULL, val=value, smaller=small; 
            }
        };
        
        int insert(Node *&root, int value) {
            if (root==NULL)
                return (root=new Node(value, 0)), 0;
                
            if (value < root->val) 
                return root->smaller++, insert(root->left, value);
            else
                return insert(root->right, value) + root->smaller + (value>root->val ? 1 : 0);
        }
        
        vector<int> countSmaller(vector<int>& nums) {
            Node *root = NULL;
            deque<int> ans;
            for (int i=nums.size()-1; i>=0; i--)
                ans.push_front(insert(root, nums[i]));
                
            return vector<int> (ans.begin(), ans.end());
        }
    };

----------------------------------------------------------------------------------------------------
