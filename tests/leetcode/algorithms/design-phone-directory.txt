Java three methods, 23ms, 36 ms, 58ms(with heap), performance explained
Basic idea is same as ugly number II, new ugly number is generated by multiplying a prime with previous generated ugly number. One catch is need to remove duplicate

Let's start with the **common solution** from ugly number II **36 ms, Theoretically O(kN)**

    public int nthSuperUglyNumberI(int n, int[] primes) {
        int[] ugly = new int[n];
        int[] idx = new int[primes.length];
    
        ugly[0] = 1;
        for (int i = 1; i < n; i++) {
            //find next
            ugly[i] = Integer.MAX_VALUE;
            for (int j = 0; j < primes.length; j++)
                ugly[i] = Math.min(ugly[i], primes[j] * ugly[idx[j]]);
            
            //slip duplicate
            for (int j = 0; j < primes.length; j++) {
                while (primes[j] * ugly[idx[j]] <= ugly[i]) idx[j]++;
            }
        }
    
        return ugly[n - 1];
    }


If you look at the above solution, it has **redundant multiplication** can be avoided, and also two for loops can be consolidated into one. This **trade-off space for speed. 23 ms, Theoretically O(kN)**

    public int nthSuperUglyNumber(int n, int[] primes) {
            int[] ugly = new int[n];
            int[] idx = new int[primes.length];
            int[] val = new int[primes.length];
            Arrays.fill(val, 1);
    
            int next = 1;
            for (int i = 0; i < n; i++) {
                ugly[i] = next;
                
                next = Integer.MAX_VALUE;
                for (int j = 0; j < primes.length; j++) {
                    //skip duplicate and avoid extra multiplication
                    if (val[j] == ugly[i]) val[j] = ugly[idx[j]++] * primes[j];
                    //find next ugly number
                    next = Math.min(next, val[j]);
                }
            }
    
            return ugly[n - 1];
        }

Can we do better? Theoretically yes, by keep the one candidates for each prime in a **heap**, it can improve the theoretical bound to **O( log(k)N )**, but in reality it's **58 ms**. I think it's the result of using higher level object instead of primitive. Can be improved by writing an **index heap** (http://algs4.cs.princeton.edu/24pq/IndexMinPQ.java.html)


    public int nthSuperUglyNumberHeap(int n, int[] primes) {
        int[] ugly = new int[n];
    
        PriorityQueue<Num> pq = new PriorityQueue<>();
        for (int i = 0; i < primes.length; i++) pq.add(new Num(primes[i], 1, primes[i]));
        ugly[0] = 1;
    
        for (int i = 1; i < n; i++) {
            ugly[i] = pq.peek().val;
            while (pq.peek().val == ugly[i]) {
                Num nxt = pq.poll();
                pq.add(new Num(nxt.p * ugly[nxt.idx], nxt.idx + 1, nxt.p));
            }
        }
    
        return ugly[n - 1];
    }
    
    private class Num implements Comparable<Num> {
        int val;
        int idx;
        int p;
    
        public Num(int val, int idx, int p) {
            this.val = val;
            this.idx = idx;
            this.p = p;
        }
    
        @Override
        public int compareTo(Num that) {
            return this.val - that.val;
        }
    }

 

----------------------------------------------------------------------------------------------------
7 line consice O(kn) c++ solution
 Keep k pointers and update them in each iteration.   Time complexity is O(kn).

    int nthSuperUglyNumber(int n, vector<int>& primes) {
            vector<int> index(primes.size(), 0), ugly(n, INT_MAX);
            ugly[0]=1;
            for(int i=1; i<n; i++){
                for(int j=0; j<primes.size(); j++) ugly[i]=min(ugly[i],ugly[index[j]]*primes[j]);
                for(int j=0; j<primes.size(); j++) index[j]+=(ugly[i]==ugly[index[j]]*primes[j]);
            }
            return ugly[n-1];
    }

 

    

----------------------------------------------------------------------------------------------------
108ms easy to understand java solution
    public int nthSuperUglyNumber(int n, int[] primes) {
        int[] ret    = new int[n];
              ret[0] = 1;

        int[] indexes  = new int[primes.length];
       
        for(int i = 1; i < n; i++){
            ret[i] = Integer.MAX_VALUE;
            
            for(int j = 0; j < primes.length; j++){
                ret[i] = Math.min(ret[i], primes[j] * ret[indexes[j]]);
            }
            
            for(int j = 0; j < indexes.length; j++){
                if(ret[i] == primes[j] * ret[indexes[j]]){
                    indexes[j]++;
                }
            }
        }
        
        return ret[n - 1];
    }

----------------------------------------------------------------------------------------------------
Python, generators on a heap
**Solution 1** ... ~1570 ms

Using generators and `heapq.merge`. Too bad there's no `itertools.unique`.

    def nthSuperUglyNumber(self, n, primes):
        uglies = [1]
        def gen(prime):
            for ugly in uglies:
                yield ugly * prime
        merged = heapq.merge(*map(gen, primes))
        while len(uglies) < n:
            ugly = next(merged)
            if ugly != uglies[-1]:
                uglies.append(ugly)
        return uglies[-1]

---

**Solution 2** ... ~1400 ms

Same thing done differently and it's a bit faster.

    def nthSuperUglyNumber(self, n, primes):
        uglies = [1]
        merged = heapq.merge(*map(lambda p: (u*p for u in uglies), primes))
        uniqed = (u for u, _ in itertools.groupby(merged))
        map(uglies.append, itertools.islice(uniqed, n-1))
        return uglies[-1]

----------------------------------------------------------------------------------------------------
Wrong Test case
I am using Java and failed because of this case.

500000
[7,19,29,37,41,47,53,59,61,79,83,89,101,103,109,127,131,137,139,157,167,179,181,199,211,229,233,239,241,251]

OJ is expecting 127671181, however, the right answer should be greater than Integer.MAX_VALUE.

----------------------------------------------------------------------------------------------------
Using min-heap, Accepted Java and Python code
The idea is similar to 264 Ugly Number II. The insight is that each new ugly number is generated from the previous ugly number by multiplying one of the prime. Thus we can maintain a pointer for each prime which indicates the current position of the generated ugly number list. Then there is a new ugly number from each prime, then we find the minimum one from them. Naturally the minimum one can be found by min-heap.

The Java version is accepted by 474 ms, but not the python version. 

**UPDATE**: Thanks **Stefan** for pointing out that the complexity of this algorithm is **NOT** O(nlog(k)). I have modified the Python code and it was just accepted by 800 ms; the modified Java code is accepted by 160 ms. I will keep the original inefficient code here and Please check the updated code below...

Java

    import java.util.Comparator;
    import java.util.PriorityQueue;
    public class Solution {
    public int nthSuperUglyNumber(int n, int[] primes) {
		Comparator<Number> comparator = new NumberCompare();
		PriorityQueue<Number> queue = 
	            new PriorityQueue<Number>(primes.length, comparator);
		for(int i = 0; i < primes.length; i ++) 
			queue.add(new Number(primes[i], 0, primes[i]));
		int[] uglyNums = new int[n];
		uglyNums[0] = 1;
		for(int i = 1; i < n; i++){
			Number min = queue.peek();
			uglyNums[i] = min.un;
			while(queue.peek().un == min.un){
				Number tmp = queue.poll();
				queue.add(new Number(uglyNums[tmp.pos + 1] * tmp.prime, tmp.pos+1, tmp.prime)); 
			}
		}
		
		return uglyNums[n-1];
    }
    
	public class Number{
		int un;
		int pos;
		int prime;
		Number(int un, int pos, int prime){
			this.un = un;
			this.pos = pos;
			this.prime = prime;
		}
	}
	
	public class NumberCompare implements Comparator<Number>{

		@Override
		public int compare(Number x, Number y) {
			// TODO Auto-generated method stub
			if (x.un > y.un)
				return 1;
			else if (x.un < y.un)
				return -1;
			else
				return 0;
		}
	}
}



Python 

    class Solution(object):
    def nthSuperUglyNumber(self, n, primes):
        """
        :type n: int
        :type primes: List[int]
        :rtype: int
        """
        # Use the heap to find the next one
        import heapq
        q, uglyNums = [], [1]
        k = len(primes)
        for i in range(k): heapq.heappush(q, (primes[i], 0, primes[i]))
        while len(uglyNums) < n:
            x, i, p = q[0]
            uglyNums += [x]
            while q and q[0][0] == x:
                x, i, p = heapq.heappop(q)
                heapq.heappush(q, (p * uglyNums[i+1], i+1, p))
        return uglyNums[-1]
        

----------------------------------------------------------------------------------------------------
112ms C++ solution with explanation
    class Solution {
    public:
        int nthSuperUglyNumber(int n, vector<int>& primes) {
            vector<int> superUglyNumbers;
            superUglyNumbers.push_back(1);  // first super ugly number
            int numPrimes = primes.size();
            vector<int> idxs(numPrimes, 0);
            // add super ugly number up to nth 
            while(superUglyNumbers.size() < n)
            {
                int nextSuperUglyNumber = superUglyNumbers[idxs[0]]*primes[0];   // next super ugly number
                for(int i = 0; i < numPrimes; i++)
                {
                    nextSuperUglyNumber = min(nextSuperUglyNumber, superUglyNumbers[idxs[i]]*primes[i]);
                }
                for(int i = 0; i < numPrimes; i++)
                {
                    if(nextSuperUglyNumber == superUglyNumbers[idxs[i]]*primes[i])
                    {
                        idxs[i]++;
                    }
                }
                superUglyNumbers.push_back(nextSuperUglyNumber);
            }
            
            return superUglyNumbers[n-1];
        }
    };

----------------------------------------------------------------------------------------------------
