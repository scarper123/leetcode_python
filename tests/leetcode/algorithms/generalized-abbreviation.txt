Clean KMP solution with super detailed explanation
Firstly, let me share my understanding of KMP algorithm.
The key of KMP is to build a look up table that records the match result of prefix and postfix.
Value in the table means the max len of matching substring that exists in both prefix and postfix.
In the prefix this substring should starts from 0, while in the postfix this substring should ends at current index.

For example, now we have a string "ababc"
The KMP table will look like this:

> a b a b c
> 
> 0 0 1 2 0

(Note: we will not match substring with itself, so we will skip index 0)

So how does this table help us search string match faster? 

Well, the answer is if we are trying to match a char after postfix with target string and failed, then we can smartly shift the string, so that the matching string in prefix will replace postfix and now we can try to match the char after prefix with this char in target. 

Take above string as an example.

Now we try to match string "ababc" with "abababc".

We will initially have match as below

> a b a b a b c                  (string x)
> 
> a b a b c                        (string y)
> 
> 0 1 2 3 4 5 6

We found char at index 4 does not match, then we can use lookup table and shift the string y wisely.
We found table[3] = 2, which means we can shift the string y rightward by 2, and still have same but shorter prefix before index 4, like this:

> a b a b a b c (string x)

> ___a b a b c (string y)
> 
> 0 1 2 3 4 5 6

If there is a long gap between prefix and postfix, this shift can help us save a lot of time.
In the brute force way, we cannot do that because we have no information of the string. We have to compare each possible pair of chars. While in kmp, we know the information of string y so we can move smartly. We can directly jump to the next possible matching pair while discard useless pair of chars.

We are almost done with KMP, but we still have one special case that needs to be taken care of.

Say now we have a input like this:

> a a b a a a  (input String)

> 0 1 2 3 4 5  (index)

> 0 1 0 1 2 ? (KMP table)

How should we build the KMP table for this string?

Say the pointer in prefix is "x", which is at index 2 now and the pointer in postfix is "y" which is at index 5 now. we need to match "b" pointed by x with "a" pointed by y. It is an unmatched pair, how should we update the cell?

Well, we really don't need to reset it to 0, that will make us skip a valid shorter matching substring "aa". 
What we do now is just to shorten the length of substring by 1 unit and try to match a shorter substring "aa". This can be done by moving pointer x to the index recorded in [indexOf(x)-1] while keep pointer y stay still. This is because by following the value in KMP table we can always make sure previous part of prefix and postfix is matched even we have shorten their length, so we only need to care about the char after matched part in prefix and postfix.


Use above example:

Firstly we try to compare prefix "aab" with postfix "aaa", pointer in prefix now points to "b" while pointer in postfix now points to "a". So this means current len of postfix/prefix will not give a match, we need to shorten it.


So in the second step, we will fix pointer in postfix, and move pointer in prefix so that we can compare shorter prefix and postfix. The movement of pointer in prefix (say at index x) is done by using KMP table. We will set pointer in prefix to be table [indexOf(x)-1].  In this case, we will move prefix pointer to index 1. So now we try to compare prefix "aa" with postfix "aa".

Finally, we found the matching prefix and postfix, we just update the cell accordingly.


Above is my understanding of KMP algorithm, so how could we apply KMP to this problem



========================== I am just a splitter =================================



This problem asks us to add string before the input so the result string will be a palindrome.
We can convert it to an alternative problem"find the longest palindrome substring starts from index 0".
If we can get the length of such substring, then we can easily build a palindrome string by inserting the reverse part of substring after such substring before the original string. 

Example:

input string:

>  abacd

longest palindrome substring starts from 0:

> aba

Insert the reverse part of substring after palindrome substring before the head:

> dcabacd

Now the problem becomes how to find the longest palindrome substring starts from 0.
We can solve it by using a trick + KMP.

The trick is to build a temp string like this:

> s + "#" + reverse(s)

Then we run KMP on it, the value in last cell will be our solution. In this problem, we don't need to use KMP
to match strings but instead we use the lookup table in KMP to find the palindrome.

We add "#" here to force the match in reverse(s) starts from its first index
What we do in KMP here is trying to find a match between prefix in s  and a postfix in reverse(s). The match part will be palindrome substring.

Example:
input:

> catacb

Temp String:

> catacb # bcatac

KMP table:

> c  a  t  a  c  b  #  b  c  a  t  a  c
> 
> 0  0 0  0  1  0  0 0  1  2  3  4  5

In the last cell, we got a value  5. It means in s we have a substring of length 5 that is palindrome.

So, above is my understanding of KMP any solution towards this problem. Below is my code


    public String shortestPalindrome(String s) {
        String temp = s + "#" + new StringBuilder(s).reverse().toString();
        int[] table = getTable(temp);
        
        //get the maximum palin part in s starts from 0
        return new StringBuilder(s.substring(table[table.length - 1])).reverse().toString() + s;
    }
    
    public int[] getTable(String s){
        //get lookup table
        int[] table = new int[s.length()];
        
        //pointer that points to matched char in prefix part
        
        int index = 0;
        //skip index 0, we will not match a string with itself
        for(int i = 1; i < s.length(); i++){
            if(s.charAt(index) == s.charAt(i)){
                //we can extend match in prefix and postfix
                table[i] = table[i-1] + 1;
                index ++;
            }else{
                //match failed, we try to match a shorter substring
                
                //by assigning index to table[i-1], we will shorten the match string length, and jump to the 
                //prefix part that we used to match postfix ended at i - 1
                index = table[i-1];
                
                while(index > 0 && s.charAt(index) != s.charAt(i)){
                    //we will try to shorten the match string length until we revert to the beginning of match (index 1)
                    index = table[index-1];
                }
                
                //when we are here may either found a match char or we reach the boundary and still no luck
                //so we need check char match
                if(s.charAt(index) == s.charAt(i)){
                    //if match, then extend one char 
                    index ++ ;
                }
                
                table[i] = index;
            }
            
        }
        
        return table;
    }

If I messed up or misunderstood something, please leave comment below. Thanks ~

----------------------------------------------------------------------------------------------------
My 7-lines recursive Java solution
The idea is to use two anchors `j` and `i` to compare the String from beginning and end.
If `j` can reach the end, the String itself is Palindrome. Otherwise, we divide the String by `j`, and get `mid = s.substring(0, j)` and `suffix`.

We reverse `suffix` as beginning of result and recursively call `shortestPalindrome` to get result of `mid` then appedn `suffix` to get result.

        int j = 0;
        for (int i = s.length() - 1; i >= 0; i--) {
            if (s.charAt(i) == s.charAt(j)) { j += 1; }
        }
        if (j == s.length()) { return s; }
        String suffix = s.substring(j);
        return new StringBuffer(suffix).reverse().toString() + shortestPalindrome(s.substring(0, j)) + suffix;

----------------------------------------------------------------------------------------------------
C++ 8 ms KMP-based O(n) time &amp; O(n) memory solution
We can construct the following string and run KMP algorithm on it:
(s) + (some symbol not present in s) + (reversed string)

After running KMP on that string as result we get a vector **p** with values of a prefix function for each character (for definition of a prefix function see KMP algorithm description). We are only interested in the last value because it shows us the largest suffix of the reversed string that matches the prefix of the original string. So basically all we left to do is to add the first k characters of the reversed string to the original string, where k is a difference between original string size and the prefix function for the last character of a constructed string. 

    class Solution {
    public:
        string shortestPalindrome(string s) {
            string rev_s = s;
            reverse(rev_s.begin(), rev_s.end());
            string l = s + "#" + rev_s;
            
            vector<int> p(l.size(), 0);
            for (int i = 1; i < l.size(); i++) {
                int j = p[i - 1];
                while (j > 0 && l[i] != l[j])
                    j = p[j - 1];
                p[i] = (j += l[i] == l[j]);
            }
            
            return rev_s.substr(0, s.size() - p[l.size() - 1]) + s;
        }
    };

----------------------------------------------------------------------------------------------------
AC in 288 ms, simple brute force
    def shortestPalindrome(self, s):
        r = s[::-1]
        for i in range(len(s) + 1):
            if s.startswith(r[i:]):
                return r[:i] + s

Example: s = `dedcba`. Then r = `abcded` and I try these overlays (the part in `(...)` is the prefix I cut off, I just include it in the display for better understanding):

      s          dedcba
      r[0:]      abcded    Nope...
      r[1:]   (a)bcded     Nope...
      r[2:]  (ab)cded      Nope...
      r[3:] (abc)ded       Yes! Return abc + dedcba

----------------------------------------------------------------------------------------------------
My 9-lines three pointers Java solution with explanation
## Explanation ##

The key point is to find the longest palindrome starting from the first character, and then reverse the remaining part as the prefix to s. Any advice will be welcome!


    public String shortestPalindrome(String s) {
        int i = 0, end = s.length() - 1, j = end; char chs[] = s.toCharArray();
        while(i < j) {
             if (chs[i] == chs[j]) {
                 i++; j--;
             } else { 
                 i = 0; end--; j = end;
             }
        }
        return new StringBuilder(s.substring(end+1)).reverse().toString() + s;
    }

----------------------------------------------------------------------------------------------------
My easily understandable but time consuming C++ solution
The key idea is to first reverse the string, then check the max length from n to 0

    class Solution {
    public:
        string shortestPalindrome(string s) {
            string s2=s;
            reverse(s2.begin(),s2.end());
            int n=s.size(),l;
            for(l=n;l>=0;l--)
            {
                if(s.substr(0,l)==s2.substr(n-l))
                    break;
            }
            return s2.substr(0,n-l)+s;
        }
    };

----------------------------------------------------------------------------------------------------
A KMP based Java solution with explanation
The Idea of using KMP to find the shortest palindrome has been proposed in the previous post but did not have a very clear explanation on how this simple piece of code works. I will post my own understanding of why KMP method works well on this problem followed by my thinking process. 

First of All, My origin thought on this problem is to find the longest palindrome from the starting character of the string. Then we can just adding the reverse of the remaining characters to the front of the origin string to get the required shortest palindrome. However, the time complexity for finding the longest palindrome from front can cost O(n^2) and will cause a TLE when coding in Java.

Then I found this solution post [C++ 8 ms KMP-based O(n) time & O(n) memory solution][1]


  [1]: https://leetcode.com/discuss/36807/c-8-ms-kmp-based-o-n-time-&-o-n-memory-solution
 
The code and the idea were great but the explanation was somehow lacking some insight of how people construct this solution. After read the code as well as the provided explanation, I became quiet confused with the following questions:

1. Why should we have a combined string and why this string should be combined like this. Can we combined the string with the reverse string first and the origin string second?
2. What's the use of the array/vector and what value does it store? Is the numeric value represent length or something else?
3. What is "recursively" updating the index means?

In order to answer these questions, we have to look back to my origin idea which is finding the longest palindrome from the front. In fact the KMP solution use a similar idea which is **finding the longest prefix which has an identical counter part string that ends at the tail of the combined string(longest suffix)**  For example, let's say we have a string "abac#caba", then the qualified string will be "aba". 
How can we find this string? The KMP method provide us with a way to accomplish that.The detail implementation is using an array of the length of the combined string **to store the index of the character which need to be compared with the next character if current character matches the prefix's last character**. If they are the same, the index that need to be stored for the next character will be the previous stored index+1. Otherwise, we will jump further back to the index of the index to perform the same procedure until the index become zero. Then in the end, the value-1 in the last array element will represent the longest common prefix's last index value and we find the longest common prefix. Since these two strings are reversed and identical string, it must be a palindrome which fulfills my origin goal of finding the longest palindrome from the starting character. 

One example for the above process for the string s **"abac#caba"**. we will have the stored indexes be **"0,0,1,0,0,1,2,3"** .Let's say we are at index 7 of the string s and the character is 'b' and in the array we have 1 for the previous index 6. This means the character at index 1 will need to be compared with character b to decide whether the common prefix from the front can continue to grow or not. Since both characters at  index 1 and at index 7 are 'b', the common prefix grows into length 2 which is"ab". 

Back to the first question, since the KMP method will help us find the longest prefix that exist in the body of the new string and we want to find the longest palindrome prefix of the origin string. We have to have the origin string at front and reverse string follows. For the second question, the array store index of the prefix that need to be match for the next character. For the last question, the recursive update happens when the matching failure so we jump to the further back to match early index in the prefix.

Below is my AC code in Java 


    public class Solution {
        public String shortestPalindrome(String s) {
            if(s.length()<=1) return s;
            String new_s = s+"#"+new StringBuilder(s).reverse().toString();
            int[] position = new int[new_s.length()];
            
            for(int i=1;i<position.length;i++)
            {
                int pre_pos = position[i-1];
                while(pre_pos>0 && new_s.charAt(pre_pos)!=new_s.charAt(i))
                    pre_pos = position[pre_pos-1];
                position[i] = pre_pos+((new_s.charAt(pre_pos)==new_s.charAt(i))?1:0);
            }
            
            return new StringBuilder(s.substring(position[position.length-1])).reverse().toString()+s;
        }
    }



----------------------------------------------------------------------------------------------------
Accepted 4ms c++ solution, different with KMP-based solution and easy understand.
For this problem,  [KMP-based solution][1] is a very typical and classic O(n) solution. Here is a different solution, it's also O(n), and I think it is more easy to understand.

In order to slove this problem, the key is to get the length of the longest palindromic prefix substring. if the length of s is `len`, and the length of the longest palindromic prefix substring is `longest`, the remaining substring will be `s.substr(longest, len - longest)`, than we should reverse the remaining substring and adding it in front of s.

For example, if s is `"abacbbcda"`, so the longest palindromic prefix substring is `"aba"`(not `"cbbc"` because it's not prefix string), and the remaining substring is `"cbbcda"`, we reverse the remaining substring and get `"adcbbc"`, so the result is `"adcbbc" + "abacbbcda"`.

The follow is my c++ solution, only 4ms. Please note that the condition in for loop is `begin <= len / 2` instead of `begin < len`, because if `begin > len / 2`, the substring can not be prefix string, so there is no need to continue.

**Update: I made wrong analysis, the complexity is O(N^2) but not O(N). Thanks very much for Sammax's reminder.**

    class Solution {
    public:
        std::string shortestPalindrome(std::string s) {
    		int len = s.length();
    		if (len < 2)
    			return s;
			// calculate the length of the longest palindromic prefix substring.
    		int longest = 1, start, end;
    		for (int begin = 0; begin <= len / 2;) {
    			start = end = begin;
    			while (end < len - 1 && s[end + 1] == s[end])
    				++end;
    			begin = end + 1;
    			while (end < len - 1 && start > 0 && s[end + 1] == s[start - 1]) {
    				++end;
    				--start;
    			}
				// start == 0 means the palindromic substring is also prefix string.
    			if (start == 0 && longest < end - start + 1)
    				longest = end - start + 1;
    		}
			// reverse the remaining substring and adding it in front of s.
    		std::string remaining = s.substr(longest, len - longest);
    		std::reverse(remaining.begin(), remaining.end());
    		return remaining + s;
        }
    };

  [1]: https://leetcode.com/discuss/36807/c-8-ms-kmp-based-o-n-time-&-o-n-memory-solution

----------------------------------------------------------------------------------------------------
Accepted C++ solution, easy to understand.
The general idea is very simple: reverse s at first and compare substr of s with its reversed version.


    string shortestPalindrome(string s)
        {
            int n = s.size();
            if(n == 0) return s;
            
            int i = n;
            string v = s; 
            reverse(v.begin(), v.end());  //Reverse s.
            
            for(; i >= 1; --i)
            {
                if(s.substr(0, i) == v.substr(n - i)) break;    //palindrome?
            }
            for(; i < s.size(); i += 2) s = s[i] + s;   //Construct
            return s;
        }

----------------------------------------------------------------------------------------------------
My C++ O(n) solution, based on Manacher&#x27;s algorithm
The brute-force method is O(N^2),which gets TLE. So have to move to Manacher's algorithm, which is O(N) time. Such algorithm returns the maximum length of the palindrome string centered at i, so we just need to find the maximum length palindrome string with the left end point at 0. Then we can construct the result. The Manacher's algorithm codes are partially copied from this site.

    class Solution {
    public:
    // Transform S into T.
    // For example, S = "abba", T = "^#a#b#b#a#$".
    // ^ and $ signs are sentinels appended to each end to avoid bounds checking
    string preProcess(string s) {
      int n = s.length();
      if (n == 0) return "^$";
      string ret(2*n+3, '#');
      ret[0] = '^';ret[2*n+1] = '$';
      for (int i = 1; i <= n; i++)  ret[2*i]=s[i-1];
     
      return ret;
    }
        
    string shortestPalindrome(string s) {
    
      int len = s.size();
      if(len<=1) return s;
      string T = preProcess(s);
      const int n = T.length();
      int P[n], i_mirror;
      int C = 0, R = 0;
      
      for (int i = 1; i < n-1; i++) {
        i_mirror = 2*C-i; // equals to i' = C - (i-C)
        
        P[i] = (R > i) ? min(R-i, P[i_mirror]) : 0;
        
        // Attempt to expand palindrome centered at i
        while (T[i + 1 + P[i]] == T[i - 1 - P[i]])
          P[i]++;
     
        // If palindrome centered at i expand past R,
        // adjust center based on expanded palindrome.
        if (i + P[i] > R) {
          C = i;
          R = i + P[i];
        }
      }
     
      // Just changed this part, 
      int maxLen = 0;
      int centerIndex = 0;
      for (int i = 1; i < n-1; i++) {
        if (1==i-P[i]) maxLen = P[i];
      }
      string temp = s.substr(maxLen);
      reverse(temp.begin(),temp.end());
      return temp+s;
            
        }
    };

Also KMP based method added, where T is an array to save the maximum length of the Palindrome substring ending at res[i]. 

class Solution {
public:
    string shortestPalindrome(string s) {
       const int len = s.size();
       string res = s;
       if(len>1)
       {
           reverse(res.begin(), res.end());
           res = s + '&' + res;
           
           int i, T[2*len+1];
           T[0] = 0;
           
           for(i=1; i<=2*len; i++)
           {
               T[i] = T[i-1];
               while(T[i]>0 && res[i]!=res[T[i]]) T[i] = T[T[i]-1];
               T[i] += (res[i] ==res[T[i]]);
           }
           
           return res.substr(len+1,len-T[2*len]) + s;
       }
       return s;
    }
};



----------------------------------------------------------------------------------------------------
Python solution(KMP)
    class Solution:
    # @param {string} s
    # @return {string}
    def shortestPalindrome(self, s):
        A=s+"*"+s[::-1]
        cont=[0]
        for i in range(1,len(A)):
            index=cont[i-1]
            while(index>0 and A[index]!=A[i]):
                index=cont[index-1]
            cont.append(index+(1 if A[index]==A[i] else 0))
        return s[cont[-1]:][::-1]+s

----------------------------------------------------------------------------------------------------
My recursive Python solution
The Idea is simple, we use `j` to compare character from end of `s` and beginning of `s`. If it's equal, increment `j` by `1`.

So we can use `j-len(s)` to divide `s` in two parts. The first part is that we don't know it's Palindrome. The second part its that we know for sure its the `suffix` of result and it may need reversed and insert at beginning of result.

The fun part is this: `s[::-1][:len(s)-j]`
if `len(s)-j` is `0`, it will eliminate as `''`, otherwise it equals `reversed(s[j-len(s):])`
It's same as:

    if len(s) - j == 0:
        return ''
    else:
        return s[j-len(s):][::-1]

Whole solution:

        if not s or len(s) == 1:
            return s
        j = 0
        for i in reversed(range(len(s))):
            if s[i] == s[j]:
                j += 1
        return s[::-1][:len(s)-j] + self.shortestPalindrome(s[:j-len(s)]) + s[j-len(s):]

----------------------------------------------------------------------------------------------------
Sharing my 4ms C++ solution
    class Solution {
    public:
        string shortestPalindrome(string s) {
            int n = s.length();
            int leftMost=0;
            int rightMost=0;
            int i=0, start, end;
            while(i<n)
            {
                start = i;
                while(s[i]==s[start])
                {
                    i++;
                }
                end = i-1;
                while(start-1>=0 && end+1<n && s[start-1]==s[end+1])
                {
                    start--;
                    end++;
                }
                if(start==0 && (end-start) > (rightMost-leftMost))
                {
                    leftMost = 0;
                    rightMost = end;
                }
            }
            
            string result;
            if(rightMost<n-1)
            {
                result = s.substr(rightMost+1, n-rightMost);
                reverse(result.begin(), result.end());
            }
            result = result + s;
            
            return result;
        }
    };

----------------------------------------------------------------------------------------------------
4ms C++ solution based on KMP with detailed comments
    class Solution 
    {
        // The entries of T are constructed so that if we have a match 
        // starting at s[j] that fails when comparing s[j + i] with W[i], 
        // then the next possible match will start at index (j + i - T[i]) 
        // in s (that is, T[i] is the amount of "backtracking" we need to 
        // do after a mismatch).
        // W -- the pattern string which is searched for in s.
        // T -- the backtrack table.
        // m -- the length of W.
        void BuildBackTrackTable(string &W, vector<int> &T, int m)
        {
            // To find T[i], we must discover a proper suffix of W[0,...,(i - 1)]
            // which is also a proper prefix of W.
            // If s[j] doesn't match W[0], we should jump to s[j + 1].
            T[0] = -1;
            if (m >= 2)
            {
                // There is no proper suffix of W[0, 1], so T[1] = 0.
                T[1] = 0;
                
                // Calculate T[i] for 2 <= i <= m - 1.
                int pos = 2;
                int cnd = 0; // the end character of the proper prefix
                while (pos <= m - 1)
                {
                    if (W[pos - 1] == W[cnd])
                    {
                        // The new character is equal to the character right 
                        // after the previous prefix, so we increase the 
                        // proper prefix by 1 character.
                        cnd++;
                        T[pos] = cnd;
                        pos++;
                    }
                    else if (cnd > 0)
                    {
                        // The previous proper prefix can't be prolonged, so 
                        // we fall back to previous proper prefix.
                        cnd = T[cnd];
                    }
                    else
                    {
                        // If cnd == 0, i.e., the minimum proper prefix still 
                        // doesn't work, then set T[pos] to 0.
                        T[pos] = 0;
                        pos++;
                    }
                }
            }
        }
        
    public:
        string shortestPalindrome(string s) 
        {
            int len = s.length();
            // If the string length is smaller than 2, the string 
            // itself is a palindrome.
            if (len < 2)
            {
                return s;
            }
            
            // To find the shortest palindrome, it is equivalent to 
            // find the longest substring which is a prefix of s and 
            // also a palindrome. This is essentially a string comparison  
            // problem: given a substring, check whether its first half 
            // is equal to its second half. 
            // (1) If two halves are equal, we are done.
            // (2) If not, we can shrink the substring and do the 
            // string comparison again. Assume that subLen is the length 
            // of the substring; s[i] is the first character in the first 
            // half of the substring which is not equal to the corresponding 
            // character s[subLen - 1 - i] in the second half of the substring.
            // Then the next substring for the palindrome check is the 
            // prefix of the current substring with length subLen - i + T[i], 
            // where T[i] is the i-th entry in the backtrack table used 
            // in the KMP algorithm.
    
            // 1. Build the backtrack table for the first half of s.
            vector<int> T(len/2);
            string firstHalf = s.substr(0, len/2);
            BuildBackTrackTable(firstHalf, T, len/2);
            
            // 2. Keep checking whether the substring is a palindrome 
            // until we find one. Initially the substring is the string 
            // s itself.
            int subLen = len;
            int initialI = 0;
            int initialJ = subLen - 1;
            while (subLen > 1)
            {
                // Index of the first half of the substring.
                int i = initialI; 
                // Index of the second half of the substring.
                int j = initialJ; 
                bool isPalindrome = false;
                while (i < j)
                {
                    if (s[i] == s[j])
                    {
                        if ((i + 1 == j) || (i + 2 == j))
                        {
                            // This is a palindrome.
                            isPalindrome = true;
                            break;
                        }
                        else
                        {
                            // Check next pair of characters.
                            i++;
                            j--;
                        }
                    }
                    else
                    {
                        subLen = subLen - i + T[i];
                        // The first T[i] characters are the same, so we 
                        // start the comparison from s[T[i]].
                        if (i > 0)
                        {
                            initialI = T[i];
                            initialJ = subLen - 1 - T[i];
                        }
                        else
                        {
                            initialI = 0;
                            initialJ = subLen - 1;
                        }
                        
                        break;
                    }
                }
                
                if (isPalindrome)
                {
                    break;
                }
            }
            
            if (subLen < len)
            {
                // The string s is not a palindrome and we need to add 
                // characters in front of it.
                string addedPrefix = s.substr(subLen);
                reverse(addedPrefix.begin(), addedPrefix.end());
                s = addedPrefix + s;
            }
    
            return s;
        }
    };

----------------------------------------------------------------------------------------------------
Simple Javascript O(n^2) solution, 140ms
The idea of this solution is trying to find the palindrome center.  
We have 2 pointers 'head' and 'tail pointing to the expected center.  
At the begining of each loop, we find neighbors which have the same value, then adjust the pointers.  
If s[head] is equals to the s[tail], head--, tail++.   
If head is equals to 0, the result is the inverted string behind 'tail'.    
Noticed that 1. Palindrome center only existing in the first half of the string.   
2. If the center is not a single character,  they should be same letters.     

     /**
     * @param {string} s
     * @return {string}
     */
    var shortestPalindrome = function(s) {
        var prefix = "";
        var pos, head, tail;
    
         for(pos = head = tail = parseInt(s.length / 2); pos > 0; head = tail = --pos){
            while(head !== 0 && s[head - 1] === s[head]){
                head--; pos--;
            }
            while(tail != s.length - 1 && s[tail + 1] === s[tail]){
                tail++;
            }
            var isSame = true;
            while(head >= 0){
                if(s[head] !== s[tail]){
                    isSame = false;
                    break;
                }
                head--; tail++;
            }
            if(isSame){
                break;
            }
        }
    
        for(var k = s.length - 1; k >= tail && k !== 0; k--){
            prefix += s[k];
        }
        return prefix + s;
    };

----------------------------------------------------------------------------------------------------
Easy C++ Manacher
The idea is to find the longest palindromic substring of `s` that begins with `s[0]`. Then take the remaining susbtring, reverse it and append it to the beginning of `s`.

For example, given `s = "aacecaaa"`, the longest palindromic substring beginning with `s[0] = 'a'` is `"aacecaa"` and the remaining substring is `"a"`. Reverse it and append it to the beginning of `s` gives `"aaacecaaa"`. 

For `s = "abcd"`, the longest palindromic substring beginning with `s[0] = 'a'` is `"a"` and the remaining substring is `"bcd"`. Reverse it and append it to the beginning of `s` gives `"dcbabcd"`.
 
The most difficult part is to implement the Manacher's algorithm to find the longest palindromic substring starting with `s[0]`. Please refer to this [nice article][1] if you want to know how it works. 
 
The code is as follows. 

    class Solution {
    public:
        string shortestPalindrome(string s) {
            string t = process(s);
            int n = t.length(), center = 0, right = 0;
            int* palin = new int[n];
            for (int i = 1; i < n - 1; i++) {
                int i_mirror = 2 * center - i;
                palin[i] = (right > i) ? min(palin[i_mirror], right - i) : 0;
                while (t[i + palin[i] + 1] == t[i - palin[i] - 1])
                    palin[i]++;
                if (i + palin[i] > right) {
                    center = i;
                    right = i + palin[i];
                }
            }
            int pos;
            for (int i = n - 2; i; i--) {
                if (i - palin[i] == 1) {
                    pos = palin[i];
                    break;
                }
            }
            string tail = s.substr(pos); 
            reverse(tail.begin(), tail.end());
            return tail + s;
        }
    private:
        string process(string& s) {
            int n = s.length();
            string t(2 * n + 3, '#');
            t[0] = '$'; t[2 * n + 2] = '%';
            for (int i = 0; i < n; i++)
                t[2 * (i + 1)] = s[i];
            return t;
        }
    };

Note that this part of the code is just to find the ending position of the longest palindromic substring begining with `s[0]`.

    int pos;
    for (int i = n - 2; i; i--) {
        if (i - palin[i] == 1) {
            pos = palin[i];
            break;
        } 
    } 

  [1]: http://articles.leetcode.com/2011/11/longest-palindromic-substring-part-ii.html

----------------------------------------------------------------------------------------------------
Using KMP&#x27;s LPS (longest-prefix-suffix) computation to solve in linear O(N) time

    class Solution {
    private:
    
        // the straightforward solution is in O(N^2); using KMP's preprocessing algorithm,
        // we can reduce this to O(N)
        int longest_palindrome_prefix(const string &s) const
        {
            /**
             * The LPS computation can determine, at any given index i in a string S, the maximum suffix length that
             * make up a suffix equal to the prefix. For example: S = "acexxxaceyyy": at S[6], S[7], and S[8] will be
             * marked with "1", "2", and "3" respectively because "a", "ac", and "ace" at this points in the string
             * make up substrings whose suffixes equal to the string's prefix. This computation can be done in one
             * linear scan of the string in O(N) time, using a secondary integer array in O(N) space.
             * 
             * For our purpose in finding the longest palindrome prefix of a string, the idea is simple:
             * if we reverse the string, then appending it to the original string (after a special marker),
             * the palindromic prefix will show up at the end of the compound string! If we then apply the above algorithm,
             * by the end of the linear scan, we'll have a number that correspond to the maximum suffix length of
             * the entire compound string, which correspond to a suffix = prefix. And since a palindromic prefix, when
             * reversed and appended, will show up as the suffix, we will conveniently have computed the maximum
             * length of the palindromic prefix!
             * 
             * For example: consider the string S = "abbaaax". The longest palindrome prefix is "abba".
             * 1. Create S' = "abbaaax#xaaabba"
             * 2. Compute LPS: lps[] = { 0,  0,  0,  1,  1,  1,  0,  0,  0,  1,  1,  1,  2,  3,  4 }
             *            from  S'[] = {'a','b','b','a','a','a','x','#','x','a','a','a','b','b','a'}
             * 3. The last element of LPS, 4, is our longest palindrome prefix length!
             */
            string kmprev = s;
            std::reverse(kmprev.begin(), kmprev.end());
            string kmp = s + "#" + kmprev;
    
            vector<int> lps(kmp.size(), 0);   // lps[i] = longest suffix length for substring kmp[0..i] where the suffix == prefix
            for (int i = 1; i < (int)lps.size(); ++i)
            {
                int prev_idx = lps[i - 1];
    
                while (prev_idx > 0 && kmp[i] != kmp[prev_idx])
                {
                    prev_idx = lps[prev_idx - 1];
                }
    
                lps[i] = prev_idx + (kmp[i] == kmp[prev_idx] ? 1 : 0);
            }
    
            // after KMP's LPS preprocessing, the last index of the LPS array will contain the longest palindrome prefix' length!
            return lps[lps.size() - 1];
        }
    
    public:
    
        string shortestPalindrome(const string &s)
        {
            //
            // The idea is simple: find the longest palindrome that prefixes the string S.
            // The shortest palindrome we can make is by reversing the rest of the string S, and then
            // prepending it to the string.
            //
            // The trick is finding that longest palindrome prefix in an efficient manner.
            //
            if (s.size() <= 1)
            {
                return string(s);
            }
    
            int k = longest_palindrome_prefix(s);
    
            string the_rest = s.substr(k);
            std::reverse(the_rest.begin(), the_rest.end());
    
            return the_rest + s;
        }
    
    };


----------------------------------------------------------------------------------------------------
Using Longest Palindrome
        public String shortestPalindrome(String s) {
            if (s == null || s.length() <= 1) return s;
            // find the longest palin beginning at the left
            int l = s.length();
            int maxL = 0;
            for(int i = 0; i <= l /2 ; i++) {
                maxL = Math.max(maxL, Math.max(expand(s, i, false),expand(s, i, true)));
            }
            // use maxL as point
            String suffix = s.substring(maxL+1);
            return new StringBuffer(suffix).reverse().toString() + s.substring(0, maxL+1) + suffix;
        }
        
        // return the end index if the palin starts at beginning
        private int expand(String s, int i, boolean isCenter) {
            int j = isCenter? i: i+1;
            while(i >=0 && j < s.length() && s.charAt(i) == s.charAt(j)){
                i--;
                j++;
            }
            // only return if goes to the start
            if (i < 0 ) return --j;
            return -1;
        }

----------------------------------------------------------------------------------------------------
Java Solution using Manacher Algorithm
This is my solution using [Manacher Algorithm][1].

The Manacher Algorithm is used to find the longest palindromic substring, we can modify it to search to obtain the longest palindromic substring starting at index 0.

Once we have the longest palindrome starting at 0, we insert the remaining characters from the original string 1 by 1 at the head of the original string.

	

        public static String manacherize(String s) {
    		StringBuilder ms = new StringBuilder("^");
    		for(int i=0;i<s.length();i++) {
    			ms.append("#"+s.charAt(i));
    		}
    		ms.append("#$");
    		return ms.toString();
    	}
    	public static String longestPalindromeStartingFrom0(String s) {
    		if(s.length()==0) return "";
    		String T = manacherize(s);
    		int[] P = new int[T.length()];
    		int C = 0;
    		int R = 0;
    		for(int i=1;i<T.length()-1;i++) {
    			int imirror = C-(i-C);
    			P[i] = (R > i) ? Math.min(R-i, P[imirror]) : 0;
    			while(T.charAt(i+1+P[i])==T.charAt(i-1-P[i])) {
    				P[i]++;
    			}
    			if(i+P[i]>R) {
    				C = i;
    				R = i + P[i];
    			}
    		}
    		int maxLen = 0;
    		int maxCenter = 0;
    		for(int i=1;i<P.length-1;i++) {
    			if(P[i]>maxLen && i-P[i]==1) {
    				maxLen = P[i];
    				maxCenter = i;
    			}
    		}
    		int start = (maxCenter-1-maxLen)/2;
    		return s.substring(start,start+maxLen);
    	}
    	
    	public static String shortestPalindrome(String s) {
    		String pal = longestPalindromeStartingFrom0(s);
    		StringBuilder prefix = new StringBuilder();
    		for(int i=pal.length();i<s.length();i++) {
    			prefix.insert(0, s.charAt(i));
    		}
    		return prefix+s;
    	}


  [1]: http://articles.leetcode.com/2011/11/longest-palindromic-substring-part-ii.html

----------------------------------------------------------------------------------------------------
Easy Java solution
First, we can find the longest palindrome which include the first character in s, then we just need to reverse the suffix and add it to the front of string s.

When looking for the longest palindrome, we start from the center and traverse to left and right, and we need to think the length of the palindrome could be odd or even.

    public class Solution {
    public String shortestPalindrome(String s) {
        int n = s.length();
        if(n<=1){
            return s;
        }
        int idx = 0;
        for(int center = n/2; center>=0; center--){
            if(valid(s, center, 1)){   //is the longest valid palindrome? (assume length is even)
                idx = 2*center+1;
                break;
            }
            if(valid(s, center, 0)){  //assume length is odd
                idx = 2*center;
                break;
            }
            
        }
        String suffix = s.substring(idx+1);
        StringBuilder b = new StringBuilder(suffix);
        return b.reverse().toString()+s;
    }
    boolean valid(String s, int center, int shift){
        int i = center, j = center+shift;
        while(i>=0 && j<s.length()){
            if(s.charAt(i)!=s.charAt(j)){
                break;
            }
            i--;
            j++;
        }
        return i<0;
    }
}

----------------------------------------------------------------------------------------------------
