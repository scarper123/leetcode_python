Share two similar Java solution that Accpted by OJ.
The solution contains two steps 1 Use BFS to construct a graph. 2. Use DFS to construct the paths from end to start.Both solutions got AC within 1s. 

The first step BFS is quite important. I summarized three tricks

1) Using a **MAP** to store the min ladder of each word, or use a **SET** to store the words visited in current ladder, when the current ladder was completed, delete the visited words from unvisited. That's why I have two similar solutions. 


2) Use **Character iteration** to find all possible paths. Do not compare one word to all the other words and check if they only differ by one character.


3) One word is allowed to be inserted into the queue only **ONCE**. See my comments.


    public class Solution {
    	Map<String,List<String>> map;
    	List<List<String>> results;
        public List<List<String>> findLadders(String start, String end, Set<String> dict) {   	
            results= new ArrayList<List<String>>();
            if (dict.size() == 0)
    			return results;
            
            int min=Integer.MAX_VALUE;
            
            Queue<String> queue= new ArrayDeque<String>();
            queue.add(start);
            
    		map = new HashMap<String,List<String>>();
    		
    		Map<String,Integer> ladder = new HashMap<String,Integer>();
    		for (String string:dict)
    		    ladder.put(string, Integer.MAX_VALUE);
    		ladder.put(start, 0);
    				
    		dict.add(end);
    		//BFS: Dijisktra search
    		while (!queue.isEmpty()) {
    		   
    			String word = queue.poll();
    			
    			int step = ladder.get(word)+1;//'step' indicates how many steps are needed to travel to one word. 
    			
    			if (step>min) break;
    			
    			for (int i = 0; i < word.length(); i++){
    			   StringBuilder builder = new StringBuilder(word); 
    				for (char ch='a';  ch <= 'z'; ch++){
    					builder.setCharAt(i,ch);
    					String new_word=builder.toString();				
    					if (ladder.containsKey(new_word)) {
    							
    					    if (step>ladder.get(new_word))//Check if it is the shortest path to one word.
    					    	continue;
    					    else if (step<ladder.get(new_word)){
    					    	queue.add(new_word);
    					    	ladder.put(new_word, step);
    					    }else;// It is a KEY line. If one word already appeared in one ladder,
    					          // Do not insert the same word inside the queue twice. Otherwise it gets TLE.
    					    
    					    if (map.containsKey(new_word)) //Build adjacent Graph
    					    	map.get(new_word).add(word);
    					    else{
    					    	List<String> list= new LinkedList<String>();
    					    	list.add(word);
    					    	map.put(new_word,list);
    					    	//It is possible to write three lines in one:
    					    	//map.put(new_word,new LinkedList<String>(Arrays.asList(new String[]{word})));
    					    	//Which one is better?
    					    }
    					    
    					    if (new_word.equals(end))
    					    	min=step;
    
    					}//End if dict contains new_word
    				}//End:Iteration from 'a' to 'z'
    			}//End:Iteration from the first to the last
    		}//End While
    
        	//BackTracking
    		LinkedList<String> result = new LinkedList<String>();
    		backTrace(end,start,result);
    
    		return results;        
        }
        private void backTrace(String word,String start,List<String> list){
        	if (word.equals(start)){
        		list.add(0,start);
        		results.add(new ArrayList<String>(list));
        		list.remove(0);
        		return;
        	}
        	list.add(0,word);
        	if (map.get(word)!=null)
        		for (String s:map.get(word))
        			backTrace(s,start,list);
        	list.remove(0);
        }
    }


Another solution using two sets. This is similar to the answer in the  most viewed thread. While I found my solution more readable and efficient. 

    public class Solution {
    	List<List<String>> results;
    	List<String> list;
    	Map<String,List<String>> map;
    	    public List<List<String>> findLadders(String start, String end, Set<String> dict) {
    	        results= new ArrayList<List<String>>();
    	        if (dict.size() == 0)
    				return results;
    	        
    	        int curr=1,next=0;	        
    	        boolean found=false;	        
    	        list = new LinkedList<String>();	       
    			map = new HashMap<String,List<String>>();
    			
    			Queue<String> queue= new ArrayDeque<String>();
    			Set<String> unvisited = new HashSet<String>(dict);
    			Set<String> visited = new HashSet<String>();
    			
    			queue.add(start);			
    			unvisited.add(end);
    			unvisited.remove(start);
    			//BFS
    			while (!queue.isEmpty()) {
    			   
    				String word = queue.poll();
    				curr--;				
    				for (int i = 0; i < word.length(); i++){
    				   StringBuilder builder = new StringBuilder(word); 
    					for (char ch='a';  ch <= 'z'; ch++){
    						builder.setCharAt(i,ch);
    						String new_word=builder.toString();	
    						if (unvisited.contains(new_word)){
    							//Handle queue
    							if (visited.add(new_word)){//Key statement,Avoid Duplicate queue insertion
    								next++;
    								queue.add(new_word);
    							}
    							
    							if (map.containsKey(new_word))//Build Adjacent Graph
    								map.get(new_word).add(word);
    							else{
    								List<String> l= new LinkedList<String>();
    								l.add(word);
    								map.put(new_word, l);
    							}
    							
    							if (new_word.equals(end)&&!found) found=true;		
    														
    						}
    
    					}//End:Iteration from 'a' to 'z'
    				}//End:Iteration from the first to the last
    				if (curr==0){
    					if (found) break;
    					curr=next;
    					next=0;
    					unvisited.removeAll(visited);
    					visited.clear();
    				}
    			}//End While
    
    			backTrace(end,start);
    			
    			return results;        
    	    }
    	    private void backTrace(String word,String start){
    	    	if (word.equals(start)){
    	    		list.add(0,start);
    	    		results.add(new ArrayList<String>(list));
    	    		list.remove(0);
    	    		return;
    	    	}
    	    	list.add(0,word);
    	    	if (map.get(word)!=null)
    	    		for (String s:map.get(word))
    	    			backTrace(s,start);
    	    	list.remove(0);
    	    }
    	}



----------------------------------------------------------------------------------------------------
My concise JAVA solution based on BFS and DFS
**Explanation**

The basic idea is:

1). Use BFS to find the shortest distance between start and end, tracing the distance of crossing nodes from start node to end node, and store node's next level neighbors to HashMap;

2). Use DFS to output paths with the same distance as the shortest distance from distance HashMap: compare if the distance of the next level node equals the distance of the current node + 1. 


    public List<List<String>> findLadders(String start, String end, Set<String> dict) {      
       List<List<String>> res = new ArrayList<List<String>>();         
       HashMap<String, ArrayList<String>> nodeNeighbors = new HashMap<String, ArrayList<String>>();// Neighbors for every node
       HashMap<String, Integer> distance = new HashMap<String, Integer>();// Distance of every node from the start node
       ArrayList<String> solution = new ArrayList<String>();
    
       dict.add(end);          
       bfs(start, end, dict, nodeNeighbors, distance);                 
       dfs(start, end, dict, nodeNeighbors, distance, solution, res);   
       return res;
    }
    
    // BFS: Trace every node's distance from the start node (level by level).
    private void bfs(String start, String end, Set<String> dict, HashMap<String, ArrayList<String>> nodeNeighbors, HashMap<String, Integer> distance) {
      for (String str : dict)
          nodeNeighbors.put(str, new ArrayList<String>());
    
      Queue<String> queue = new LinkedList<String>();
      queue.offer(start);
      distance.put(start, 0);
    
      while (!queue.isEmpty()) {
          int count = queue.size();
          boolean foundEnd = false;
          for (int i = 0; i < count; i++) {
              String cur = queue.poll();
              int curDistance = distance.get(cur);                
              ArrayList<String> neighbors = getNeighbors(cur, dict);
    
              for (String neighbor : neighbors) {
                  nodeNeighbors.get(cur).add(neighbor);
                  if (!distance.containsKey(neighbor)) {// Check if visited
                      distance.put(neighbor, curDistance + 1);
                      if (end.equals(neighbor))// Found the shortest path
                          foundEnd = true;
                      else
                          queue.offer(neighbor);
                      }
                  }
              }
    
              if (foundEnd)
                  break;
          }
      }
   
    // Find all next level nodes.    
    private ArrayList<String> getNeighbors(String node, Set<String> dict) {
      ArrayList<String> res = new ArrayList<String>();
      char chs[] = node.toCharArray();
    
      for (char ch ='a'; ch <= 'z'; ch++) {
          for (int i = 0; i < chs.length; i++) {
              if (chs[i] == ch) continue;
              char old_ch = chs[i];
              chs[i] = ch;
              if (dict.contains(String.valueOf(chs))) {
                  res.add(String.valueOf(chs));
              }
              chs[i] = old_ch;
          }
    
      }
      return res;
    }

    // DFS: output all paths with the shortest distance.
    private void dfs(String cur, String end, Set<String> dict, HashMap<String, ArrayList<String>> nodeNeighbors, HashMap<String, Integer> distance, ArrayList<String> solution, List<List<String>> res) {
               solution.add(cur);
       if (end.equals(cur)) {
               res.add(new ArrayList<String>(solution));
           }
           else {
               for (String next : nodeNeighbors.get(cur)) {            
                   if (distance.get(next) == distance.get(cur) + 1) {
                       dfs(next, end, dict, nodeNeighbors, distance, solution, res);
                   }
                }
           }           
           solution.remove(solution.size() - 1);
       }

----------------------------------------------------------------------------------------------------
Super fast Java solution (two-end BFS)
Thanks to prime_tang and jianchao.li.fighter!

      public List<List<String>> findLadders(String start, String end, Set<String> dict) {
        // hash set for both ends
        Set<String> set1 = new HashSet<String>();
        Set<String> set2 = new HashSet<String>();
        
        // initial words in both ends
        set1.add(start);
        set2.add(end);
        
        // we use a map to help construct the final result
        Map<String, List<String>> map = new HashMap<String, List<String>>();
        
        // build the map
        helper(dict, set1, set2, map, false);
        
        List<List<String>> res = new ArrayList<List<String>>();
        List<String> sol = new ArrayList<String>(Arrays.asList(start));
        
        // recursively build the final result
        generateList(start, end, map, sol, res);
        
        return res;
      }
      
      boolean helper(Set<String> dict, Set<String> set1, Set<String> set2, Map<String, List<String>> map, boolean flip) {
        if (set1.isEmpty()) {
          return false;
        }
        
        if (set1.size() > set2.size()) {
          return helper(dict, set2, set1, map, !flip);
        }
        
        // remove words on current both ends from the dict
        dict.removeAll(set1);
        dict.removeAll(set2);
        
        // as we only need the shortest paths
        // we use a boolean value help early termination
        boolean done = false;
        
        // set for the next level
        Set<String> set = new HashSet<String>();
        
        // for each string in end 1
        for (String str : set1) {
          for (int i = 0; i < str.length(); i++) {
            char[] chars = str.toCharArray();
            
            // change one character for every position
            for (char ch = 'a'; ch <= 'z'; ch++) {
              chars[i] = ch;
              
              String word = new String(chars);
              
              // make sure we construct the tree in the correct direction
              String key = flip ? word : str;
              String val = flip ? str : word;
                  
              List<String> list = map.containsKey(key) ? map.get(key) : new ArrayList<String>();
                  
              if (set2.contains(word)) {
                done = true;
                
                list.add(val);
                map.put(key, list);
              } 
              
              if (!done && dict.contains(word)) {
                set.add(word);
                
                list.add(val);
                map.put(key, list);
              }
            }
          }
        }
        
        // early terminate if done is true
        return done || helper(dict, set2, set, map, !flip);
      }
      
      void generateList(String start, String end, Map<String, List<String>> map, List<String> sol, List<List<String>> res) {
        if (start.equals(end)) {
          res.add(new ArrayList<String>(sol));
          return;
        }
        
        // need this check in case the diff between start and end happens to be one
        // e.g "a", "c", {"a", "b", "c"}
        if (!map.containsKey(start)) {
          return;
        }
        
        for (String word : map.get(start)) {
          sol.add(word);
          generateList(word, end, map, sol, res);
          sol.remove(sol.size() - 1);
        }
      }

----------------------------------------------------------------------------------------------------
88ms! Accepted c++ solution with two-end BFS. 68ms for Word Ladder and 88ms for Word Ladder II
In order to reduce the running time, we should use two-end BFS to slove the problem.

Accepted 68ms c++ solution for [Word Ladder][1].

    class Solution {
    public:
        int ladderLength(std::string beginWord, std::string endWord, std::unordered_set<std::string> &dict) {
    		if (beginWord == endWord)
    			return 1;
            std::unordered_set<std::string> words1, words2;
    		words1.insert(beginWord);
    		words2.insert(endWord);
            dict.erase(beginWord);
            dict.erase(endWord);
            return ladderLengthHelper(words1, words2, dict, 1);
        }
    
    private:
        int ladderLengthHelper(std::unordered_set<std::string> &words1, std::unordered_set<std::string> &words2, std::unordered_set<std::string> &dict, int level) {
    		if (words1.empty())
                return 0;
    		if (words1.size() > words2.size())
    			return ladderLengthHelper(words2, words1, dict, level);
            std::unordered_set<std::string> words3;
            for (auto it = words1.begin(); it != words1.end(); ++it) {
    			std::string word = *it;
    			for (auto ch = word.begin(); ch != word.end(); ++ch) {
    				char tmp = *ch;
                    for (*ch = 'a'; *ch <= 'z'; ++(*ch))
    					if (*ch != tmp)
    						if (words2.find(word) != words2.end())
                                return level + 1;
    						else if (dict.find(word) != dict.end()) {
                                dict.erase(word);
                                words3.insert(word);
                            }
    				*ch = tmp;
                }
            }
            return ladderLengthHelper(words2, words3, dict, level + 1);
        }
    };

Accepted 88ms c++ solution for [Word Ladder II][2].

    class Solution {
    public:
        std::vector<std::vector<std::string> > findLadders(std::string beginWord, std::string endWord, std::unordered_set<std::string> &dict) {
    		std::vector<std::vector<std::string> > paths;
    		std::vector<std::string> path(1, beginWord);
    		if (beginWord == endWord) {
    			paths.push_back(path);
    			return paths;
    		}
            std::unordered_set<std::string> words1, words2;
    		words1.insert(beginWord);
    		words2.insert(endWord);
    		std::unordered_map<std::string, std::vector<std::string> > nexts;
    		bool words1IsBegin = false;
            if (findLaddersHelper(words1, words2, dict, nexts, words1IsBegin))
    			getPath(beginWord, endWord, nexts, path, paths);
    		return paths;
        }
    private:
        bool findLaddersHelper(
    		std::unordered_set<std::string> &words1,
    		std::unordered_set<std::string> &words2,
    		std::unordered_set<std::string> &dict,
    		std::unordered_map<std::string, std::vector<std::string> > &nexts,
    		bool &words1IsBegin) {
    		words1IsBegin = !words1IsBegin;
    		if (words1.empty())
                return false;
    		if (words1.size() > words2.size())
    			return findLaddersHelper(words2, words1, dict, nexts, words1IsBegin);
    		for (auto it = words1.begin(); it != words1.end(); ++it)
    			dict.erase(*it);
    		for (auto it = words2.begin(); it != words2.end(); ++it)
    			dict.erase(*it);
            std::unordered_set<std::string> words3;
    		bool reach = false;
            for (auto it = words1.begin(); it != words1.end(); ++it) {
    			std::string word = *it;
    			for (auto ch = word.begin(); ch != word.end(); ++ch) {
    				char tmp = *ch;
                    for (*ch = 'a'; *ch <= 'z'; ++(*ch))
    					if (*ch != tmp)
    						if (words2.find(word) != words2.end()) {
    							reach = true;
    							words1IsBegin ? nexts[*it].push_back(word) : nexts[word].push_back(*it);
    						}
    						else if (!reach && dict.find(word) != dict.end()) {
    							words3.insert(word);
    							words1IsBegin ? nexts[*it].push_back(word) : nexts[word].push_back(*it);
                            }
    				*ch = tmp;
                }
            }
            return reach || findLaddersHelper(words2, words3, dict, nexts, words1IsBegin);
        }
    	void getPath(
    		std::string beginWord,
    		std::string &endWord,
    		std::unordered_map<std::string, std::vector<std::string> > &nexts,
    		std::vector<std::string> &path,
    		std::vector<std::vector<std::string> > &paths) {
    		if (beginWord == endWord)
    			paths.push_back(path);
    		else
    			for (auto it = nexts[beginWord].begin(); it != nexts[beginWord].end(); ++it) {
    				path.push_back(*it);
    				getPath(*it, endWord, nexts, path, paths);
    				path.pop_back();
    			}
    	}
    };


  [1]: https://leetcode.com/problems/word-ladder/
  [2]: https://leetcode.com/problems/word-ladder-ii/

----------------------------------------------------------------------------------------------------
The fastest C++ Solution, 56ms!!
Treat each word as a node of a tree. There are two trees. One tree's root node is "beginWord", and the other tree's root node is "endWord".

The root node can yield all his children node, and they are the second layer of the tree. The second layer can yield all their children, then we get the third layer of the tree, ... , and so on.

When one tree yield a new child, we search it in the last layer of the other tree. If we find an identical node in that tree, then we get some ladders connect two roots("beginWord" -> ... -> "endWord").

Another thing should be considered is: two(or more) different nodes may yield an identical child. That means the child may have two(or more) parents. For example, "hit" and "hot" can both yield "hat", means "hat" has two parents.

So, the data struct of tree-node is:

    class Node {
    public: 
        string word;
        vectror<Node*> parents;
        Node(string w) : word(w) {}
    }

Note: we don't need a `children` field for `Node` class, because we won't use it.

Two nodes are considered equal when their `word` field are equal. So we introduce an compare function:

    bool nodecmp(Node* pa, Node* pb)
    {
        return pa->word < pb->word;
    }

Then we use `nodecmp` as the compare function to build a node set.

    typedef bool (*NodeCmper) (Node*, Node*);
    typedef set<Node*, NodeCmper> NodeSet;
    NodeSet layer(nodecmp);

Then we can store/search pointers of nodes in node set `layer`.  For example:

    Node node1("hit"), node2("hot"), node3("hat");    
    layer.insert(&node1);
    layer.insert(&node2);
    layer.insert(&node3);
    auto itr = layer.find(new Node("hot"));
    cout << (*itr)->word; // output: hot

Using these data structures, we can solve this problem with bi-direction BFS algorithm. Below is the AC code, and it is very very fast.

    class Node;
    
    typedef vector<string> Ladder;
    typedef unordered_set<string> StringSet;
    typedef bool (*NodeCmper) (Node*, Node*);
    typedef set<Node*, NodeCmper> NodeSet;
    
    class Node
    {
    public:
        string word;
        vector<Node*> parents;
    
        Node(string w) : word(w) {}
        void addparent(Node* parent) { parents.push_back(parent); }
    
        // Yield all children of this node, and:
        //   1) If the child is found in $targetlayer, which means we found ladders that
        //      connect BEGIN-WORD and END-WORD, then we get all paths through this node
        //      to its ROOT node, and all paths through the target child node to its ROOT
        //      node, and combine the two group of paths to a group of ladders, and append
        //      these ladders to $ladders.
        //   2) Elif the $ladders is empty:
        //       2.1) If the child is found in $nextlayer, then get that child, and add
        //            this node to its parents.
        //       2.2) Else, add the child to nextlayer, and add this node to its parents.
        //   3) Else, do nothing.
        void yieldchildren(NodeSet& nextlayer, StringSet& wordlist, NodeSet& targetlayer,
                           vector<Ladder>& ladders, bool forward)
        {
            string nextword = word;
            for (int i = 0, n = nextword.length(); i < n; i++) {
                char oldchar = nextword[i];
                for (nextword[i] = 'a'; nextword[i] <= 'z'; nextword[i]++) {
                    if (wordlist.count(nextword)) {
                        // now we found a valid child-word, let's yield a child.
                        Node* child = new Node(nextword);
                        yield1(child, nextlayer, targetlayer, ladders, forward);
                    }
                }
                nextword[i] = oldchar;
            }
        }
    
        // yield one child, see comment of function `yieldchildren`
        void yield1(Node* child, NodeSet& nextlayer, NodeSet& targetlayer,
                    vector<Ladder>& ladders, bool forward) {
            auto itr = targetlayer.find(child);
            if (itr != targetlayer.end()) {
                for (Ladder path1 : this->getpaths()) {
                    for (Ladder path2 : (*itr)->getpaths()) {
                        if (forward) {
                            ladders.push_back(path1);
                            ladders.back().insert(ladders.back().end(), path2.rbegin(), path2.rend());
                        } else {
                            ladders.push_back(path2);
                            ladders.back().insert(ladders.back().end(), path1.rbegin(), path1.rend());
                        }
                    }
                }
            } else if (ladders.empty()) {
                auto itr = nextlayer.find(child);
                if (itr != nextlayer.end()) {
                    (*itr)->addparent(this);
                } else {
                    child->addparent(this);
                    nextlayer.insert(child);
                }
            }
        }
    
        vector<Ladder> getpaths()
        {
            vector<Ladder> ladders;
            if (parents.empty()) {
                ladders.push_back(Ladder(1, word));
            } else {
                for (Node* parent : parents) {
                    for (Ladder ladder : parent->getpaths()) {
                        ladders.push_back(ladder);
                        ladders.back().push_back(word);
                    }
                }
            }
            return ladders;
        }
    };
    
    bool nodecmp(Node* pa, Node* pb)
    {
        return pa->word < pb->word;
    }
    
    class Solution {
    public:
        vector<Ladder> findLadders(string begin, string end, StringSet& wordlist) {
            vector<Ladder> ladders;
            Node headroot(begin), tailroot(end);
            NodeSet frontlayer(nodecmp), backlayer(nodecmp);
            NodeSet *ptr_layerA = &frontlayer, *ptr_layerB = &backlayer;
            bool forward = true;
    
            if (begin == end) {
                ladders.push_back(Ladder(1, begin));
                return ladders;
            }
    
            frontlayer.insert(&headroot);
            backlayer.insert(&tailroot);
            wordlist.insert(end);
            while (!ptr_layerA->empty() && !ptr_layerB->empty() && ladders.empty()) {
                NodeSet nextlayer(nodecmp);
                if (ptr_layerA->size() > ptr_layerB->size()) {
                    swap(ptr_layerA, ptr_layerB);
                    forward = ! forward;
                }
                for (Node* node : *ptr_layerA) {
                    wordlist.erase(node->word);
                }
                for (Node* node : *ptr_layerA) {
                    node->yieldchildren(nextlayer, wordlist, *ptr_layerB, ladders, forward);
                }
                swap(*ptr_layerA, nextlayer);
            }
    
            return ladders;
        }
    };



----------------------------------------------------------------------------------------------------
Use defaultdict for traceback and easy writing, 20 lines python code
    class Solution:
    # @param start, a string
    # @param end, a string
    # @param dict, a set of string
    # @return a list of lists of string
    def findLadders(self, start, end, dic):
        dic.add(end)
        level = {start}
        parents = collections.defaultdict(set)
        while level and end not in parents:
            next_level = collections.defaultdict(set)
            for node in level:
                for char in string.ascii_lowercase:
                    for i in range(len(start)):
                        n = node[:i]+char+node[i+1:]
                        if n in dic and n not in parents:
                            next_level[n].add(node)
            level = next_level
            parents.update(next_level)
        res = [[end]]
        while res and res[0][0] != start:
            res = [[p]+r for r in res for p in parents[r[0]]]
        return res

Every level we use the defaultdict to get rid of the duplicates

----------------------------------------------------------------------------------------------------
Clean but the best-submission (68ms) in C++, well-commented
    class Solution 
    {
        public:
            vector<vector<string>> findLadders(string beginWord, string endWord, unordered_set<string> &dict) {
                vector<vector<string> > paths;
                vector<string> path(1, beginWord);
                if (beginWord == endWord)  //corner case;
                {
                    paths.push_back(path);
                    return paths;
                }
                unordered_set<string> forward, backward;
                forward.insert(beginWord);
                backward.insert(endWord);
                unordered_map<string, vector<string> > tree;
                bool reversed = false; //make sure the tree generating direction is consistent, since we have to start from the smaller set to accelerate;
                if (buildTree(forward, backward, dict, tree, reversed))
                    getPath(beginWord, endWord, tree, path, paths);
                return paths;
            }
        private:
            bool buildTree(unordered_set<string> &forward, unordered_set<string> &backward, unordered_set<string> &dict, unordered_map<string, vector<string> > &tree, bool reversed) 
            {
                if (forward.empty()) return false;
                if (forward.size() > backward.size()) 
                    return buildTree(backward, forward, dict, tree, !reversed);
                for (auto &word: forward) dict.erase(word);
                for (auto &word: backward) dict.erase(word);
                unordered_set<string> nextLevel;
                bool done = false; //in case of invalid further searching;
                for (auto &it: forward) //traverse each word in the forward -> the current level of the tree;
                {
                    string word = it;
                    for (auto &c: word) 
                    {
                        char c0 = c; //store the original;
                        for (c = 'a'; c <= 'z'; ++c) //try each case;
                        {
                            if (c != c0) //avoid futile checking;
                            {
                                if (backward.count(word))  //using count is an accelerating method;
                                {
                                    done = true;
                                    !reversed ? tree[it].push_back(word) : tree[word].push_back(it); //keep the tree generation direction consistent;
                                }
                                else if (!done && dict.count(word))
                                {
                                    nextLevel.insert(word);
                                    !reversed ? tree[it].push_back(word) : tree[word].push_back(it);
                                }
                            }
                        }
                        c = c0; //restore the word;
                    }
                }
                return done || buildTree(nextLevel, backward, dict, tree, reversed);
            }
    
            void getPath(string &beginWord, string &endWord, unordered_map<string, vector<string> > &tree, vector<string> &path, vector<vector<string> > &paths) //using reference can accelerate;
            {
                if (beginWord == endWord) paths.push_back(path); //till the end;
                else
                {
                    for (auto &it: tree[beginWord]) 
                    {
                        path.push_back(it);
                        getPath(it, endWord, tree, path, paths); //DFS retrieving the path;
                        path.pop_back();
                    }
                }
            }
    };

----------------------------------------------------------------------------------------------------
FAST AND CLEAN Python&#x2F;C++ Solution using Double BFS, beats 98%
    import string
    
    class Solution(object):
    
        # Solution using double BFS
    
        def findLadders(self, begin, end, words_list):
    
            def construct_paths(begin, end, tree, path, paths):
                if begin == end:
                    paths.append(path)
                    return
                if begin in tree:
                    for elem in tree[begin]:
                        construct_paths(elem, end, tree, path + [elem], paths)
    
            def add_path(tree, word, neigh, is_forw):
                if is_forw:
                    tree[word] = tree.get(word, []) + [neigh]
                else:
                    tree[neigh] = tree.get(neigh, []) + [word]
    
            def bfs_level(this_lev, oth_lev, tree, is_forw, words_set):
                if len(this_lev) == 0:
                    return False
                if len(this_lev) > len(oth_lev):
                    return bfs_level(oth_lev, this_lev, tree, not is_forw, words_set)
                for word in (this_lev | oth_lev):
                    words_set.discard(word)
                next_lev = set()
                done = False
                while len(this_lev):
                    word = this_lev.pop()
                    for c in string.ascii_lowercase:
                        for index in range(len(word)):
                            neigh = word[:index] + c + word[index+1:]
                            if neigh in oth_lev:
                                done = True
                                add_path(tree, word, neigh, is_forw)                
                            if not done and neigh in words_set:
                                next_lev.add(neigh)
                                add_path(tree, word, neigh, is_forw)
                return done or bfs_level(next_lev, oth_lev, tree, is_forw, words_set)
                                
            tree, path, paths = {}, [begin], []
            is_found = bfs_level(set([begin]), set([end]), tree, True, words_list)
            construct_paths(begin, end, tree, path, paths)
            return paths

----------------------------------------------------------------------------------------------------
Java Solution with Iteration
Code is about 40 lines, put explanation in comments.

    /**
     * we are essentially building a graph, from start, BF.
     * and at each level we find all reachable words from parent.
     * we stop if the current level contains end,
     * we return any path whose last node is end.
     * 
     * to achieve BFT, use a deuqe;
     * a key improvement is to remove all the words we already reached
     * in PREVIOUS LEVEL; we don't need to try visit them again
     * in subsequent level, that is guaranteed to be non-optimal solution.
     * at each new level, we will removeAll() words reached in previous level from dict.
     */
    public List<List<String>> findLadders(String start, String end, Set<String> dict) {
        List<List<String>> results = new ArrayList<List<String>>();
        dict.add(end);
        // instead of storing words we are at, we store the paths.
        Deque<List<String>> paths = new LinkedList<List<String>>();
        List<String> path0 = new LinkedList<String>();
        path0.add(start);
        paths.add(path0);
        // if we found a path ending at 'end', we will set lastLevel,
        // use this data to stop iterating further.
        int level = 1, lastLevel = Integer.MAX_VALUE;
        Set<String> wordsPerLevel = new HashSet<String>();
        while (!paths.isEmpty()) {
            List<String> path = paths.pollFirst();
            if (path.size() > level) {
                dict.removeAll(wordsPerLevel);
                wordsPerLevel.clear();
                level = path.size();
                if (level > lastLevel)
                    break; // stop and return
            }
            //  try to find next word to reach, continuing from the path
            String last = path.get(level - 1);
            char[] chars = last.toCharArray();
            for (int index = 0; index < last.length(); index++) {
                char original = chars[index];
                for (char c = 'a'; c <= 'z'; c++) {
                    chars[index] = c;
                    String next = new String(chars);
                    if (dict.contains(next)) {
                        wordsPerLevel.add(next);
                        List<String> nextPath = new LinkedList<String>(path);
                        nextPath.add(next);
                        if (next.equals(end)) {
                            results.add(nextPath);
                            lastLevel = level; // curr level is the last level
                        } else
                            paths.addLast(nextPath);
                    }
                }
                chars[index] = original;
            }
        }
        
        return results;
    }

----------------------------------------------------------------------------------------------------
A concise solution using bfs and backtracing
the basic idea is referred from url: http://yucoding.blogspot.com/2014/01/leetcode-question-word-ladder-ii.html
    
    unordered_map<string, vector<string> > mp; // a map indicating a word's previous word list
    vector<vector<string> > res;
    vector<string> path;
     
    void output(string &start, string last) {
        if (last == start) {
            // vector<string> t(path.rbegin(), path.rend());
            // res.push_back(t);
            reverse(path.begin(), path.end());
            res.push_back(path);
            reverse(path.begin(), path.end());
        }
        else {
            // backtracing to get path recursively
            for (int i = 0; i < mp[last].size(); ++i) {
                path.push_back(mp[last][i]);
                output(start, mp[last][i]);
                path.pop_back();
            }
        }
    }
    
    void findNext(string str, unordered_set<string> &dict, unordered_set<string> &next_lev) {
        for (int i = 0; i < str.size(); ++i) {
            string s = str;
            for (char j = 'a'; j <= 'z'; ++j) {
                s[i] = j;
                if (dict.count(s)) {
                    next_lev.insert(s);
                    mp[s].push_back(str);
                }
            }
        }
    }
    
    vector<vector<string> > findLadders(string start, string end, unordered_set<string> &dict) {
        unordered_set<string> cur_lev;
        cur_lev.insert(start);
        unordered_set<string> next_lev;
        path.push_back(end);
         
        // expand to get all the next level valid words
        while (true) {
            for (auto it = cur_lev.begin(); it != cur_lev.end(); it++)
                dict.erase(*it); //delete previous level words from dict to avoid the cycle
             
            for (auto it = cur_lev.begin(); it != cur_lev.end(); it++)
                findNext(*it, dict, next_lev); //find current level words
             
            if (next_lev.empty()) return res;
            
            if (next_lev.count(end)) { //if find end string
                output(start, end);
                return res;
            }
            
            cur_lev = next_lev;
            next_lev.clear();
        }
        
        return res;    
    }

----------------------------------------------------------------------------------------------------
My 30ms bidirectional BFS and DFS based Java solution
Regarding speed, 30ms solution beats 100% other java solutions.

Couple of things that make this solution fast:

1) We use Bidirectional BFS which always expand from direction with less nodes

2) We use char[] to build string so it would be fast 

3) Instead of scanning dict each time, we build new string from existing string and check if it is in dict

Below is my commented code.

    public List<List<String>> findLadders(String beginWord, String endWord, Set<String> wordList) {
        //we use bi-directional BFS to find shortest path
        
        Set<String> fwd = new HashSet<String>();
        fwd.add(beginWord);
        
        Set<String> bwd = new HashSet<String>();
        bwd.add(endWord);
        
        Map<String, List<String>> hs = new HashMap<String, List<String>>();
        BFS(fwd, bwd, wordList, false, hs);
        
        List<List<String>> result = new ArrayList<List<String>>();
        
        //if two parts cannot be connected, then return empty list
        if(!isConnected) return result;
        
        //we need to add start node to temp list as there is no other node can get start node
        List<String> temp = new ArrayList<String>();
        temp.add(beginWord);
        
        DFS(result, temp, beginWord, endWord, hs);
        
        return result;
    }
    
    //flag of whether we have connected two parts
    boolean isConnected = false;
    
    public void BFS(Set<String> forward, Set<String> backward, Set<String> dict, boolean swap, Map<String, List<String>> hs){
        
        //boundary check
        if(forward.isEmpty() || backward.isEmpty()){
            return;
        }
        
        //we always do BFS on direction with less nodes
        //here we assume forward set has less nodes, if not, we swap them
        if(forward.size() > backward.size()){
            BFS(backward, forward, dict, !swap, hs);
            return;
        }
        
        //remove all forward/backward words from dict to avoid duplicate addition
        dict.removeAll(forward);
        dict.removeAll(backward);
        
        //new set contains all new nodes from forward set
        Set<String> set3 = new HashSet<String>();
        
        //do BFS on every node of forward direction
        for(String str : forward){
            //try to change each char of str
            for(int i = 0; i < str.length(); i++){
                //try to replace current char with every chars from a to z 
                char[] ary = str.toCharArray();
                for(char j = 'a'; j <= 'z'; j++){
                    ary[i] = j;
                    String temp = new String(ary);
                    
                    //we skip this string if it is not in dict nor in backward
                    if(!backward.contains(temp) && !dict.contains(temp)){
                        continue;
                    }
                    
                    //we follow forward direction    
                    String key = !swap? str : temp;
                    String val = !swap? temp : str;

                    if(!hs.containsKey(key)) hs.put(key, new ArrayList<String>());
                    
                    //if temp string is in backward set, then it will connect two parts
                    if(backward.contains(temp)){
                        hs.get(key).add(val);
                        isConnected = true;
                    }
                    
                    //if temp is in dict, then we can add it to set3 as new nodes in next layer
                    if(!isConnected && dict.contains(temp)){
                        hs.get(key).add(val);
                        set3.add(temp);
                    }
                }
                
            }
        }
        
        //to force our path to be shortest, we will not do BFS if we have found shortest path(isConnected = true)
        if(!isConnected){
            BFS(set3, backward, dict, swap, hs);
        }
    }
    
    public void DFS(List<List<String>> result, List<String> temp, String start, String end, Map<String, List<String>> hs){
        //we will use DFS, more specifically backtracking to build paths
        
        //boundary case
        if(start.equals(end)){
            result.add(new ArrayList<String>(temp));
            return;
        }
        
        //not each node in hs is valid node in shortest path, if we found current node does not have children node,
        //then it means it is not in shortest path
        if(!hs.containsKey(start)){
            return;
        }
        
        for(String s : hs.get(start)){
            temp.add(s);
            DFS(result, temp, s, end, hs);
            temp.remove(temp.size()-1);
            
        }
    }


The main idea is from [awesome solution][1]


  [1]: https://leetcode.com/discuss/44110/super-fast-java-solution-two-end-bfs

----------------------------------------------------------------------------------------------------
Share my 130 ms Python solution
Main idea:

1. Use character flipping

2. Two-end BFS

3. defaultdict(list) for easy writing to keep track of paths

I also use set intersection to determine if we are done

    from collections import defaultdict
    class Solution:
        # @param start, a string
        # @param end, a string
        # @param dict, a set of string
        # @return a list of lists of string
        def findLadders(self, start, end, dict):
            wordLen = len(start)
            front, back = defaultdict(list), defaultdict(list)
            front[start].append([start])
            back[end].append([end])
            # remove start from dict, add end to dict if it is not there
            dict.discard(start)
            if end not in dict:
                dict.add(end)
            forward, result = True, []
            while front:
                # get all valid transformations
                nextSet = defaultdict(list)
                for word, paths in front.items():
                    for index in range(wordLen):
                        for ch in 'abcdefghijklmnopqrstuvwxyz':
                            nextWord = word[:index] + ch + word[index+1:]
                            if nextWord in dict:
                                # update paths
                                if forward:
                                    # append next word to path
                                    nextSet[nextWord].extend([path + [nextWord] for path in paths])
                                else:
                                    # add next word in front of path
                                    nextSet[nextWord].extend([[nextWord] + path for path in paths])
                front = nextSet
                common = set(front) & set(back)
                if common:
                    # path is through
                    if not forward:
                        # switch front and back if we were searching backward
                        front, back = back, front
                    result.extend([head + tail[1:] for word in common for head in front[word] for tail in back[word]])
                    return result
    
                if len(front) > len(back):
                    # swap front and back for better performance (smaller nextSet)
                    front, back, forward = back, front, not forward
    
                # remove transformations from wordDict to avoid cycles
                dict -= set(front)
    
            return []


----------------------------------------------------------------------------------------------------
Input None Output None , 1&#x2F;1 Test Case Passed Wrong Answer
 When I submit the code below, OJ tells me that the input was NONE, output was NONE , 1/1 test case passed and the answer is WRONG. I am not sure how to diagnose this problem . 

Did anyone else face this issue?

    public class Solution {
           	public List<String> getNeighbors(String str, Set<String> dict){
        		List<String> result = new ArrayList<String>();
        		for(int i = 0; i < str.length() ; i++){
        			for(int j = 0 ; j < 26 ;j ++){
        				StringBuilder sb = new StringBuilder(str);
        				char c = (char) ('a' + j);
        				if(str.charAt(i) != c){
        					sb.setCharAt(i, c);
        					String s = sb.toString();
        					if(dict.contains(s)){
        						result.add(s);
        					}
        				}
        			}
        		}
        		return result;
        	}
        
        	public List<List<String>> findLadders(String start, String end, Set<String> wordList) {
        		List<List<String>> result = new ArrayList<List<String>>();
        		
        		Queue<String> wordQueue = new LinkedList<String>();
        		wordQueue.add(start);
        		Set<String> wordsUsed = new HashSet<String>();
        		wordsUsed.add(start);
        		wordList.add(end);
        		Map<String,List<String>> incoming = new HashMap<String, List<String>>();
        		
        		// build the incoming map 
        		while(!wordQueue.isEmpty()){
        			String word = wordQueue.remove();
        			if(word.equals(end)){
        				break;
        			}
        			for(String neigh : getNeighbors(word, wordList)){
        				if(!wordsUsed.contains(neigh)){
        					wordsUsed.add(neigh);
        					if(!incoming.containsKey(neigh)){
        						incoming.put(neigh, new ArrayList<String>());
        					}
        					incoming.get(neigh).add(word);
        					wordQueue.add(neigh);
        				}
        			}
        		}
        		
        		//DFS the incoming map to get all the paths
        		buildPathsDFS( end,  start,  incoming, result,new ArrayList<String>());
        		
        		return result;
        	}
        	
        	public void buildPathsDFS(String start, String end, Map<String,
        			List<String>> incoming,List<List<String>> result,List<String> curPath){
        
        		if(start.equals(end)){
        			curPath.add(end);
        			List<String> temp = new ArrayList<String>(curPath);
        			Collections.reverse(temp);
        			result.add(temp);
        			curPath.remove(end);
        			return;
        		}
        
        		if(incoming.containsKey(start)){
        			curPath.add(start);
        			for(String next : incoming.get(start)){
        				buildPathsDFS(next, end, incoming, result, curPath);
        			}
        			curPath.remove(start);
        		}
        	}
        	
        }

----------------------------------------------------------------------------------------------------
C++ solution using standard BFS method, no DFS or backtracking
    vector<vector<string>> findLadders(string beginWord, string endWord, unordered_set<string> &wordList) {
        //very interesting problem
        //It can be solved with standard BFS. The tricky idea is doing BFS of paths instead of words!
        //Then the queue becomes a queue of paths.
        vector<vector<string>> ans;
        queue<vector<string>> paths;
        wordList.insert(endWord);
        paths.push({beginWord});
        int level = 1;
        int minLevel = INT_MAX;
        
        //"visited" records all the visited nodes on this level
        //these words will never be visited again after this level 
        //and should be removed from wordList. This is guaranteed
        // by the shortest path.
        unordered_set<string> visited; 
        
        while (!paths.empty()) {
            vector<string> path = paths.front();
            paths.pop();
            if (path.size() > level) {
                //reach a new level
                for (string w : visited) wordList.erase(w);
                visited.clear();
                if (path.size() > minLevel)
                    break;
                else
                    level = path.size();
            }
            string last = path.back();
            //find next words in wordList by changing
            //each element from 'a' to 'z'
            for (int i = 0; i < last.size(); ++i) {
                string news = last;
                for (char c = 'a'; c <= 'z'; ++c) {
                    news[i] = c;
                    if (wordList.find(news) != wordList.end()) {
                    //next word is in wordList
                    //append this word to path
                    //path will be reused in the loop
                    //so copy a new path
                        vector<string> newpath = path;
                        newpath.push_back(news);
                        visited.insert(news);
                        if (news == endWord) {
                            minLevel = level;
                            ans.push_back(newpath);
                        }
                        else
                            paths.push(newpath);
                    }
                }
            }
        }
        return ans;
    }


----------------------------------------------------------------------------------------------------
Time Limit Exceeded for &quot;nape&quot;, &quot;mild&quot;
I used BFS approach and kept a map for getting paths. I used dp approach for faster retrievel but i am still getting TLE for "nape" "mild" input (achieved to get correct results on my pc). Can anyone point ways to decrease time consumption?


    public ArrayList<ArrayList<String>> findLadders(String start,
    			String end, HashSet<String> dict) {
    
    		ArrayList<ArrayList<String>> ret = new ArrayList<ArrayList<String>>();
    		Queue<String> que = new LinkedList<String>();
    		que.add(start);
    		String dummy = "dummuuuOO";
    		HashSet<String> used = new HashSet<String>();
    		if (!dict.contains(end))
    			return ret;
    		que.add(dummy);
    		dict.remove(start);
    		HashMap<String, Set<String>> path = new HashMap<String, Set<String>>();
    		HashSet<String> usedTemp = new HashSet<String>();
    		HashMap<String, ArrayList<String>> dictMemory = new HashMap<String, ArrayList<String>>();
    		int count = 0;
    		while (que.size() > 1) {
    			String current = que.poll();
    			if (current.equals(end)) {
    				HashMap<String, ArrayList<ArrayList<String>>> mem = new HashMap<String, ArrayList<ArrayList<String>>>();
    				ret.addAll(generateList(start, end, path, mem, count));
    				break;
    			}
    			if (current.equals(dummy)) {
    				count++;
    				que.add(dummy);
    				used.addAll(usedTemp);
    				usedTemp.clear();
    				continue;
    			}
    			ArrayList<String> list = getNextFromDict(current, dict, dictMemory, end);
    			for (String next : list) {
    				if (!used.contains(next)) {
    					Set<String> nl = path.get(next) == null ? new HashSet<String>()
    							: path.get(next);
    					nl.add(current);
    					path.put(next, nl);
    					usedTemp.add(next);
    					que.add(next);
    				}
    			}
    		}
    		return ret;
    	}
    
    	private  ArrayList<String> getNextFromDict(String current,
    			HashSet<String> dict, HashMap<String, ArrayList<String>> dictMemory, String last) {
    		if (dictMemory.get(current) != null)
    			return dictMemory.get(current);
    		ArrayList<String> ret = new ArrayList<String>();
    		for (int n = 0; n < current.length(); n++) {
    			String check = current.substring(0, n) + String.valueOf(last.charAt(n))
    					+ current.substring(n + 1);
    			if (dict.contains(check))
    				ret.add(check);
    			for (char c = 'a'; c < 'z'; c++) {
    				if (current.charAt(n) != c && last.charAt(n) != c) {
    					String key = current.substring(0, n) + String.valueOf(c)
    							+ current.substring(n + 1);
    					if (dict.contains(key))
    						ret.add(key);
    				}
    			}
    		}
    		dictMemory.put(current, ret);
    		return ret;
    	}
    
    	private  ArrayList<ArrayList<String>> generateList(String start,
    			String end, HashMap<String, Set<String>> path,
    			HashMap<String, ArrayList<ArrayList<String>>> memory, int count) {
    		ArrayList<ArrayList<String>> ret = new ArrayList<ArrayList<String>>();
    		if (count < 0)
    			return null;
    		if (memory.get(end) != null) {
    			if (memory.get(end) != null && memory.get(end).size() > 0
    					&& memory.get(end).get(0).size() == count+1){
    				ArrayList<ArrayList<String>> cache1 = new ArrayList<ArrayList<String>>();
    				ArrayList<String> cache2 = new ArrayList<String>();
    				cache2.addAll(memory.get(end).get(0));
    				cache1.add(cache2);
    				return cache1;
    			}
    			else
    				return null;
    		}
    		String key = end;
    		if (key.equals(start)) {
    			ArrayList<String> l = new ArrayList<String>();
    			l.add(key);
    			ret.add(l);
    			ArrayList<ArrayList<String>> retClone = new ArrayList<ArrayList<String>>();
    			for (ArrayList<String> list : ret) {
    				ArrayList<String> lClone = new ArrayList<String>();
    				lClone.addAll(list);
    				retClone.add(lClone);
    			}
    			memory.put(end, retClone);
    			return ret;
    		}
    
    		Set<String> prev = path.get(key);
    		for (String p : prev) {
    			ArrayList<ArrayList<String>> generateList = generateList(start, p,
    					path, memory, count-1);
    			if (generateList != null) {
    				for (ArrayList<String> pth : generateList) {
    					pth.add(key);
    					ret.add(pth);
    				}
    			}
    		}
    		ArrayList<ArrayList<String>> retClone = new ArrayList<ArrayList<String>>();
    		for (ArrayList<String> list : ret) {
    			ArrayList<String> lClone = new ArrayList<String>();
    			lClone.addAll(list);
    			retClone.add(lClone);
    		}
    		memory.put(end, retClone);
    		return ret;
    	}



----------------------------------------------------------------------------------------------------
Python solution in 578ms
The trick is use `set` to save the words at each level because different words could ladder to the same word. It was 2580ms using `list`.
      
    alphabet = set('abcdefghijklmnopqrstuvwxyz')
    def findLadders(self, start, end, dict):
        dict.add(end)
        level_tracker = collections.defaultdict(set)
        self.parents_tracker = {}
        last = {start}
        while last and end not in level_tracker:
            current = set([])
            level_tracker.clear()
            for word in last:
                for next_word in self.ladder(word, dict):
                    if next_word not in self.parents_tracker:
                        current.add(next_word)
                        level_tracker[next_word].add(word)
            self.parents_tracker.update(level_tracker)
            last = current
        return [] if not last else self.generate_paths(start, end)
        
    def ladder(self, word, dict):
        for i in xrange(len(word)):
            for letter in self.alphabet - {word[i]}:
                new_word = word[:i] + letter + word[i + 1:]
                if new_word in dict:
                    yield new_word
    
    def generate_paths(self, start, end):
        ret = [[end]]
        while ret[-1][0] != start:
            new_ret = []
            for path in ret:
                for parent in self.parents_tracker[path[0]]:
                    new_ret.append([parent] + path)
            ret = new_ret
        return ret

----------------------------------------------------------------------------------------------------
Java Implementation vs. C++ Implementation
An extremely strange question here...

First I solve this problem with BFS building search graph + DFS build paths. However I tried my best optimizing but got Time Limit Exceeded (I've tried three ways of building path". After profiling, it seems in the building path part, copying ArrayList consumes too much time.

After that I simply "translate" the code into C++ with stl, and got AC easily.

May I know the time limits for these two implementations?

----------------------------------------------------------------------------------------------------
Java code based on Dijkstra&#x27;s algorithm. Accepted.
The difference from the Word Ladder solution is that now we need to remember all possible previous nodes in the path to the node when solution is optimal. And after that construct all possible path variants.

    static private class WordVertex implements Comparable<WordVertex>{
		
		private String word;
		private int dist;
		private List<WordVertex> prev;
		private HashSet<WordVertex> neighbors;
		
		private WordVertex(String w) {
			word = w;
			dist = Integer.MAX_VALUE;
			neighbors = new HashSet<WordVertex>();
			prev = new LinkedList<WordVertex>();
		}
		
		@Override
		public int compareTo(WordVertex o) {
			if (dist < o.dist) {
				return -1;
			} else if (dist > o.dist) {
				return 1;
			}
			return 0;
		}
	}
	
	public List<List<String>> findLadders(String start, String end, Set<String> dict) {
		
		// Init vertices
		WordVertex startVertex = new WordVertex(start);
		WordVertex endVertex = new WordVertex(end);
		startVertex.dist = 0;
		List<WordVertex> vertices = new ArrayList<WordVertex>();
		vertices.add(startVertex);
		vertices.add(endVertex);
		for (String word:dict) {
			vertices.add(new WordVertex(word));
		}
		
		// Construct graph
		for(int i=0; i<vertices.size(); i++) {
			WordVertex vertex = vertices.get(i);
			for(int j=i+1; j<vertices.size(); j++) {
				WordVertex neighbor = vertices.get(j);
				int diff = 0;
				for (int k=0; k<vertex.word.length(); k++) {
					if (vertex.word.charAt(k) != neighbor.word.charAt(k) && diff++ == 1) {
						break;
					}
				}
				if (diff == 1) {
					vertex.neighbors.add(neighbor);
					neighbor.neighbors.add(vertex);
				}
				
			}
		}
		
		// Find shortest path. Dijkstra's algorithm.
		PriorityQueue<WordVertex> queue = new PriorityQueue<WordVertex>();
		for (WordVertex v:vertices) {
			queue.add(v);
		}
		while(!queue.isEmpty()) {
			WordVertex v = queue.poll();
			if (v.dist == Integer.MAX_VALUE) continue;
			for (WordVertex n:v.neighbors) {
				if (v.dist + 1 <= n.dist) {
					n.dist = v.dist + 1;
					n.prev.add(v);   // as one of the previous candidates
					queue.remove(n);
					queue.add(n);
				} 
			}
		}
		
		// Make result
		List<List<String>> seqs = new LinkedList<List<String>>();
		LinkedList<String> seq = new LinkedList<String>();
		constructSequences(endVertex, startVertex, seq, seqs);
		
		return seqs;
    }
	
	void constructSequences(WordVertex v, WordVertex start, LinkedList<String> seq, List<List<String>> seqs) {
		seq.addFirst(v.word);
		if (v == start) {
			seqs.add(new LinkedList<String>(seq));
		}
		for(WordVertex p:v.prev) {
			constructSequences(p, start, seq, seqs);
		}
		seq.removeFirst();
	}

----------------------------------------------------------------------------------------------------
My java BFS solution
basically first u construct a graph in which the nodes are the words in dictionary, and two nodes are connected if they are different only by one char. 

then we find the min paths from starting word to ending word. this is done using BFS. at each node we trace back to upstream using a list of possible upstream nodes.


    public class Solution {
        List<List<String>> result = new ArrayList<List<String>>();
        List<Integer> partialAnswer = new ArrayList<Integer>();
        ArrayList<String> dictionary;
        public List<List<String>> findLadders(String start, String end, Set<String> dict) {
           ArrayList<String> words = new ArrayList<String>();
           words.addAll(dict);
           
           dictionary = words;
           
           boolean ok[][] = new boolean[words.size()][words.size()];
           for(int i=0;i<words.size();i++) {
               for(int j=0;j<words.size();j++) {
                   if (i==j) ok[i][j] = true;
                   else 
                    ok[i][j] = findWordsDistance(words.get(i), words.get(j));
               }
           }
           
           // bfs traversal
           int startingIdx = words.indexOf(start);
           int endingIdx = words.indexOf(end);
           
           int used[] = new int[words.size()];
           ArrayList<Integer> incoming[] = new ArrayList[words.size()];
           for(int i=0;i<words.size();i++)
            incoming[i] = new ArrayList<Integer>();
            
           Queue<Integer> q = new LinkedList<Integer>();
           q.add(startingIdx);
           used[startingIdx] = 1;
           while( q.size() != 0 ) {
               Integer startFrom = q.poll();
               if (startFrom == endingIdx)
                break;
               for(int i=0;i<words.size();i++){
                   if (ok[startFrom][i]) {
                       if (used[i]==0) {
                        q.add(i);
                        used[i] = used[startFrom] +1;
                       }
                       if (used[startFrom] +1 <= used[i])
                       incoming[i].add(startFrom);
                   }
               }
           }
           
           // trace back
           trace(incoming, startingIdx, endingIdx);
           
           return result;
        }
        
        void trace(List<Integer>[] incoming, int start, int end) {
            if ( start == end) {
                // collect
                ArrayList<String> list = new ArrayList<String>();
                            list.add(dictionary.get(end));
    
                for(int i=partialAnswer.size()-1;i>=0;i--)
                    list.add(dictionary.get(partialAnswer.get(i)));
                result.add(list);
                return;
            }
            
            partialAnswer.add(end);
            for(int upstream : incoming[end]) {
                trace(incoming, start, upstream);
            }
            partialAnswer.remove(partialAnswer.size()-1);
        }
        
        boolean findWordsDistance(String a, String b) {
            if (a.length() != b.length()) return false;
            int diff = 0;
            for(int i=0;i<a.length();i++) {
                if (a.charAt(i) != b.charAt(i)) {
                    if (++diff >1)
                        return false;
                }
            }
            return true;
        }
    }

----------------------------------------------------------------------------------------------------
Is word ladder 2 crashed?
I run the test and that is what i got:
Word Ladder II

Submission Details
1 / 1 test cases passed.
Status: Wrong Answer
Input:
None
Output:
Expected:
None

----------------------------------------------------------------------------------------------------
