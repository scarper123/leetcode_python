O(n log k) C++ using multiset and updating middle-iterator
vector<double> medianSlidingWindow(vector<int>& nums, int k) {
    multiset<int> window(nums.begin(), nums.begin() + k);
    auto mid = next(window.begin(), k / 2);
    vector<double> medians;
    for (int i=k; ; i++) {

        // Push the current median.
        medians.push_back((double(*mid) + *prev(mid, 1 - k%2)) / 2);

        // If all done, return.
        if (i == nums.size())
            return medians;
            
        // Insert nums[i].
        window.insert(nums[i]);
        if (nums[i] < *mid)
            mid--;

        // Erase nums[i-k].
        if (nums[i-k] <= *mid)
            mid++;
        window.erase(window.lower_bound(nums[i-k]));
    }
}

----------------------------------------------------------------------------------------------------
Easy to understand O(nlogk) Java solution using TreeMap
public class Solution {
    public double[] medianSlidingWindow(int[] nums, int k) {
        double[] res = new double[nums.length-k+1];
        TreeMap<Integer, Integer> minHeap = new TreeMap<Integer, Integer>();
        TreeMap<Integer, Integer> maxHeap = new TreeMap<Integer, Integer>(Collections.reverseOrder());
        
        int minHeapCap = k/2; //smaller heap when k is odd.
        int maxHeapCap = k - minHeapCap; 
        
        for(int i=0; i< k; i++){
            maxHeap.put(nums[i], maxHeap.getOrDefault(nums[i], 0) + 1);
        }
        int[] minHeapSize = new int[]{0};
        int[] maxHeapSize = new int[]{k};
        for(int i=0; i< minHeapCap; i++){
            move1Over(maxHeap, minHeap, maxHeapSize, minHeapSize);
        }
        
        res[0] = getMedian(maxHeap, minHeap, maxHeapSize, minHeapSize);
        int resIdx = 1;
        
        for(int i=0; i< nums.length-k; i++){
            int addee = nums[i+k];
            if(addee <= maxHeap.keySet().iterator().next()){
                add(addee, maxHeap, maxHeapSize);
            } else {
                add(addee, minHeap, minHeapSize);
            }
            
            int removee = nums[i];
            if(removee <= maxHeap.keySet().iterator().next()){
                remove(removee, maxHeap, maxHeapSize);
            } else {
                remove(removee, minHeap, minHeapSize);
            }

            //rebalance
            if(minHeapSize[0] > minHeapCap){
                move1Over(minHeap, maxHeap, minHeapSize, maxHeapSize);
            } else if(minHeapSize[0] < minHeapCap){
                move1Over(maxHeap, minHeap, maxHeapSize, minHeapSize);
            }
            
            res[resIdx] = getMedian(maxHeap, minHeap, maxHeapSize, minHeapSize);
            resIdx++;
        }
        return res;
    }

    public double getMedian(TreeMap<Integer, Integer> bigHeap, TreeMap<Integer, Integer> smallHeap, int[] bigHeapSize, int[] smallHeapSize){
        return bigHeapSize[0] > smallHeapSize[0] ? (double) bigHeap.keySet().iterator().next() : ((double) bigHeap.keySet().iterator().next() + (double) smallHeap.keySet().iterator().next()) / 2.0;
    }
    
    //move the top element of heap1 to heap2
    public void move1Over(TreeMap<Integer, Integer> heap1, TreeMap<Integer, Integer> heap2, int[] heap1Size, int[] heap2Size){
        int peek = heap1.keySet().iterator().next();
        add(peek, heap2, heap2Size);
        remove(peek, heap1, heap1Size);
    }
    
    public void add(int val, TreeMap<Integer, Integer> heap, int[] heapSize){
        heap.put(val, heap.getOrDefault(val,0) + 1);
        heapSize[0]++;
    }
    
    public void remove(int val, TreeMap<Integer, Integer> heap, int[] heapSize){
        if(heap.put(val, heap.get(val) - 1) == 1) heap.remove(val);
        heapSize[0]--;
    }
}


----------------------------------------------------------------------------------------------------
Java solution using two PriorityQueues
public class Solution {
    PriorityQueue<Integer> minHeap = new PriorityQueue<Integer>();
    PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(
        new Comparator<Integer>() {
            public int compare(Integer i1, Integer i2) {
                return i2.compareTo(i1);
            }
        }
    );
	
    public double[] medianSlidingWindow(int[] nums, int k) {
        int n = nums.length - k + 1;
	if (n <= 0) return new double[0];
        double[] result = new double[n];
        
        for (int i = 0; i <= nums.length; i++) {
            if (i >= k) {
        	result[i - k] = getMedian();
        	remove(nums[i - k]);
            }
            if (i < nums.length) {
        	add(nums[i]);
            }
        }
        
        return result;
    }
    
    private void add(int num) {
	if (num < getMedian()) {
	    maxHeap.add(num);
	}
	else {
	    minHeap.add(num);
	}
	if (maxHeap.size() > minHeap.size()) {
            minHeap.add(maxHeap.poll());
	}
        if (minHeap.size() - maxHeap.size() > 1) {
            maxHeap.add(minHeap.poll());
        }
    }
	
    private void remove(int num) {
	if (num < getMedian()) {
	    maxHeap.remove(num);
	}
	else {
	    minHeap.remove(num);
	}
	if (maxHeap.size() > minHeap.size()) {
            minHeap.add(maxHeap.poll());
	}
        if (minHeap.size() - maxHeap.size() > 1) {
            maxHeap.add(minHeap.poll());
        }
    }
	
    private double getMedian() {
	if (maxHeap.isEmpty() && minHeap.isEmpty()) return 0;
	    
	if (maxHeap.size() == minHeap.size()) {
	    return ((double)maxHeap.peek() + (double)minHeap.peek()) / 2.0;
	}
	else {
            return (double)minHeap.peek();
	}
    }
}


----------------------------------------------------------------------------------------------------
O(n*log(n)) Time C++ Solution Using Two Heaps and a Hash Table
class Solution {
public:
    vector<double> medianSlidingWindow(vector<int>& nums, int k) {
        vector<double> medians;
        unordered_map<int, int> hash;                          // count numbers to be deleted
        priority_queue<int, vector<int>> bheap;                // heap on the bottom
        priority_queue<int, vector<int>, greater<int>> theap;  // heap on the top
        
        int i = 0;
        
        // Initialize the heaps
        while (i < k)  { bheap.push(nums[i++]); }
        for (int count = k/2; count > 0; --count) {
            theap.push(bheap.top()); bheap.pop();
        }
        
        while (true) {
            // Get median
            if (k % 2) medians.push_back(bheap.top());
            else medians.push_back( ((double)bheap.top() + theap.top()) / 2 );
            
            if (i == nums.size()) break;
            int m = nums[i-k], n = nums[i++], balance = 0;
            
            // What happens to the number m that is moving out of the window
            if (m <= bheap.top())  { --balance;  if (m == bheap.top()) bheap.pop(); else ++hash[m]; }
            else                   { ++balance;  if (m == theap.top()) theap.pop(); else ++hash[m]; }
            
            // Insert the new number n that enters the window
            if (!bheap.empty() && n <= bheap.top())  { ++balance; bheap.push(n); }
            else                                     { --balance; theap.push(n); }
            
            // Rebalance the bottom and top heaps
            if      (balance < 0)  { bheap.push(theap.top()); theap.pop(); }
            else if (balance > 0)  { theap.push(bheap.top()); bheap.pop(); }
            
            // Remove numbers that should be discarded at the top of the two heaps
            while (!bheap.empty() && hash[bheap.top()])  { --hash[bheap.top()]; bheap.pop(); }
            while (!theap.empty() && hash[theap.top()])  { --hash[theap.top()]; theap.pop(); }
        }
        
        return medians;
    }
};


----------------------------------------------------------------------------------------------------
Easy Python O(nk)
def medianSlidingWindow(self, nums, k):
    window = sorted(nums[:k])
    medians = []
    for a, b in zip(nums, nums[k:] + [0]):
        medians.append((window[k/2] + window[~(k/2)]) / 2.)
        window.remove(a)
        bisect.insort(window, b)
    return medians

----------------------------------------------------------------------------------------------------
Java using two Tree Sets - O(n logk)
public double[] medianSlidingWindow(int[] nums, int k) {
    Comparator<Integer> comparator = (a, b) -> nums[a] != nums[b] ? Integer.compare(nums[a], nums[b]) : a - b;
    TreeSet<Integer> left = new TreeSet<>(comparator.reversed());
    TreeSet<Integer> right = new TreeSet<>(comparator);
    
    Supplier<Double> median = (k % 2 == 0) ?
        () -> ((double) nums[left.first()] + nums[right.first()]) / 2 :
        () -> (double) nums[right.first()];
    
    // balance lefts size and rights size (if not equal then right will be larger by one)
    Runnable balance = () -> { while (left.size() > right.size()) right.add(left.pollFirst()); };
    
    double[] result = new double[nums.length - k + 1];
    
    for (int i = 0; i < k; i++) left.add(i);
    balance.run(); result[0] = median.get();
    
    for (int i = k, r = 1; i < nums.length; i++, r++) {
        // remove tail of window from either left or right
        if(!left.remove(i - k)) right.remove(i - k);

        // add next num, this will always increase left size
        right.add(i); left.add(right.pollFirst());
        
        // rebalance left and right, then get median from them
        balance.run(); result[r] = median.get();
    }
    
    return result;
}


----------------------------------------------------------------------------------------------------
C++ Solution O(n*k)
public:
    vector<double> medianSlidingWindow(vector<int>& nums, int k) {
        multiset<int> mp;
        vector<double> med;
        
        for(int i=0; i<k-1; ++i) mp.insert(nums[i]);
        
        for(int i=k-1; i< nums.size(); ++i){
            mp.insert(nums[i]); // Add the next number
            
            auto itb = mp.begin(); advance(itb, (k-1)/2); //Find the lower median
            auto ite = mp.end(); advance(ite, -(k+1)/2); //Find the upper median
        
            double avg = ((long)(*itb) + (*ite)) / 2.0;
            med.push_back(avg);
        
            mp.erase(mp.find(nums[i-k+1])); //Remove the oldest element
        }
        
        return med;
    }
};

----------------------------------------------------------------------------------------------------
Python Hash Heap Implementation
# This is the Python implementation of Hash Heap based on the list implementation 
# of binary heap. The difference between Hash Heap and Binary Heap is that Hash
# Heap supports the `heapRemove` operation in O(log n) time and can check whether
# certain element is in the Hash Heap or not in O(1) time.
# 
# Basic automatic tests are given in `pushpopTest()` and `removeTest()`.
# Note: It may takes about 10 seconds to run both test functions.

# import random module for test use.
import random

class HeapNode(object):
    """
    The node in the HashHeap to deal with duplicates.
    Each node store the value of each element and the number of duplicates
    with the same value.
    """
    def __init__(self, val, cnt):
        self.val = val
        self.cnt = cnt

    def __cmp__(self, other):
        return self.val - other.val

    def __str__(self):
        return "[%s, %d]" % (self.val, self.cnt)
    __repr__ = __str__

class HashHeap(object):
    """
    This HashHeap is the same as the list implementation of binary heap, but with
    a hashMap to map the value of one elemnt to its index in the list.
    """
    def __init__(self, arr):
        """
        `_cap` - the number of elements in the HashHeap
        `_maxIdx` - the max index of the binary heap
        `_data` - the list implementation of the binary heap
        `_hashMap` - mapping the element to its index in the binary heap
        """
        elemCnt = self._preProcess(arr)
        self._cap = len(arr)
        self._maxIdx = len(elemCnt) - 1
        self._data = [HeapNode(key, value) for key, value in elemCnt.items()]
        self._hashMap = {node.val: idx for idx, node in enumerate(self._data)}
        self._heapify()

    def _preProcess(self, arr):
        """
        Convert the input array into a dict object.
        The key to the dict is the value of the element.
        The value of the dict is the occurence of each element.
        """
        elemCnt = {}
        for elem in arr:
            elemCnt[elem] = elemCnt.get(elem, 0) + 1
        return elemCnt

    def _swap(self, idx1, idx2):
        """
        Swap the 2 elements in the heap.
        Also, change the index stored in `self._hashMap`
        """
        elem1, elem2 = self._data[idx1], self._data[idx2]
        self._hashMap[elem1.val] = idx2
        self._hashMap[elem2.val] = idx1
        self._data[idx1], self._data[idx2] = elem2, elem1

    def _heapify(self):
        idx = self._maxIdx
        while idx > 0:
            parentIdx = (idx - 1) / 2
            if self._data[parentIdx] > self._data[idx]:
                self._swap(parentIdx, idx)
                self._siftDown(idx)
            idx -= 1

    def _siftDown(self, idx):
        def heapValid(idx):
            left, right = idx * 2 + 1, idx * 2 + 2
            if left > self._maxIdx:
                return True
            if right > self._maxIdx:
                return self._data[idx] <= self._data[left]
            return self._data[idx] <= self._data[left] and self._data[idx] <= self._data[right]
        def smallerChild(idx):
            left, right = idx * 2 + 1, idx * 2 + 2
            if left > self._maxIdx:
                return None
            if right > self._maxIdx:
                return left
            return left if self._data[left] < self._data[right] else right

        current = idx
        while not heapValid(current):
            child = smallerChild(current)
            self._swap(current, child)
            current = child

    def _siftUp(self, idx):
        current = idx
        parent = (current - 1) / 2
        while current > 0 and self._data[parent] > self._data[current]:
            self._swap(parent, current)
            current = parent
            parent = (current - 1) / 2

    def _removeLastNode(self):
        rmNode = self._data.pop(-1)
        self._cap -= 1
        self._maxIdx -= 1
        self._hashMap.pop(rmNode.val)

    def _removeByIdx(self, idx):
        thisNode = self._data[idx]
        retVal = thisNode.val
        if thisNode.cnt > 1:
            thisNode.cnt -= 1
            self._cap -= 1
        elif idx == self._maxIdx:
            # the node itself is the last node
            self._removeLastNode()
        else:
            self._swap(idx, self._maxIdx)
            self._removeLastNode()
            pidx = (idx - 1) / 2
            # check to see we should sift up or sift down
            if pidx >= 0 and self._data[pidx] > self._data[idx]:
                self._siftUp(idx)
            else:
                self._siftDown(idx)
        return retVal

    @property
    def length(self):
        """
        Return the number of elements in the Hash Heap
        """
        return self._cap

    def heapPeep(self):
        """
        Return the MIN element in the Hash Heap
        """
        if not self._data:
            return float("inf")
        return self._data[0].val

    def heapPop(self):
        """
        Remove the MIN element from the Hash Heap and return its value
        """
        return self._removeByIdx(0)

    def heapPush(self, elem):
        """
        Push a new element into the Hash Heap
        """
        self._cap += 1
        if elem not in self._hashMap:
            self._maxIdx += 1
            self._data.append(HeapNode(elem, 1))
            self._hashMap[elem] = self._maxIdx
            self._siftUp(self._maxIdx)
        else:
            idx = self._hashMap[elem]
            self._data[idx].cnt += 1
        
    def heapRemove(self, elem):
        """
        Remove a existing element from the Hash Heap
        If the element to be removed is not in the Hash Heap, raise an error.
        """
        if elem not in self._hashMap:
            raise ValueError("Element to be removed is not in HashHeap!!!")
        idx = self._hashMap[elem]
        self._removeByIdx(idx)

    def __contains__(self, value):
        return value in self._hashMap

    def __str__(self):
        return "%s" % [elem.val for elem in self._data]
    __repr__ = __str__


def pushpopTest():
    """
    Randomly generate a list, and push each element into the heap.
    Test HeapPush by comparing the first element in the heap with the 
    smallest element in the List.
    Test HeapPop by comparing the popped element from the heap with the
    sorted list one by one. 
    """
    for _ in xrange(100):
        thisHeap = HashHeap([0])
        testList = [0]
        for i in xrange(1000):
            thisRandom = random.randrange(-100, 100000)
            thisHeap.heapPush(thisRandom)
            testList.append(thisRandom)
            assert min(testList) == thisHeap.heapPeep()
            assert len(testList) == thisHeap.length
            assert len(thisHeap._hashMap) == thisHeap._maxIdx + 1
        testList.sort()
        assert len(testList) == thisHeap.length
        for idx, num in enumerate(testList):
            assert num == thisHeap.heapPop()
            assert len(testList) - 1 - idx == thisHeap.length
            assert len(thisHeap._hashMap) == thisHeap._maxIdx + 1

def removeTest():
    """
    Randomly generate a list, and push each element into the heap.
    Test HeapRemove by randomly delete one element from the heap by the probability
    of 0.2, and then check whether the first element in the heap is the same as the
    smallest element in the list.
    """
    for _ in xrange(100):
        thisHeap = HashHeap([0])
        testList = [0]
        for i in xrange(1000):
            thisRandom = random.randrange(-100, 100000)
            thisHeap.heapPush(thisRandom)
            if random.random() < 0.2:
                thisHeap.heapRemove(thisRandom)
            else:
                testList.append(thisRandom)
            assert min(testList) == thisHeap.heapPeep()
            assert len(testList) == thisHeap.length
            assert len(thisHeap._hashMap) == thisHeap._maxIdx + 1
        testList.sort()
        assert len(testList) == thisHeap.length
        for idx, num in enumerate(testList):
            assert num == thisHeap.heapPop()
            assert len(testList) - 1 - idx == thisHeap.length
            assert len(thisHeap._hashMap) == thisHeap._maxIdx + 1


if __name__ == '__main__':
    pushpopTest()
    removeTest()


----------------------------------------------------------------------------------------------------
C++ 95 ms single multiset O(n * log n)
vector<double> medianSlidingWindow(vector<int>& nums, int k)
{
    int size = nums.size(), median_pos = k - k / 2 - 1;
    vector<double> res(size - k + 1);
    multiset<int> s(nums.begin(), nums.begin() + k);
    auto it = next(s.begin(), median_pos);

    for (auto i = k; i <= size; ++i)
    {
        res[i - k] = ((double)*it + (k % 2 != 0 ? *it : *next(it))) / 2;
        if (i < size)
        {
            // magic numbers (instead of enum) for brevity. INT_MAX means to retrace the iterator from the beginning.
            int repos_it = INT_MAX; 
            if (k > 2)
            {
                // if inserted or removed item equals to the current median, we need to retrace.
                // we do not know which exact element will be removed/inserted, and we cannot compare multiset iterators.
                // otherwise, we can keep or increment/decrement the current median iterator.
                if ((nums[i - k] < *it && nums[i] < *it) || (nums[i - k] > *it && nums[i] > *it)) repos_it = 0;
                else if (nums[i - k] < *it && nums[i] > *it) repos_it = 1; // advance forward.
                else if (nums[i - k] > *it && nums[i] < *it) repos_it = -1; // advance backward.
            }
            s.insert(nums[i]);
            s.erase(s.find(nums[i - k]));

            if (repos_it == INT_MAX) it = next(s.begin(), median_pos);
            else if (repos_it == 1) ++it;
            else if (repos_it == -1) --it;
        }
    }
    return res;
}


----------------------------------------------------------------------------------------------------
Java clean and easily readable solution with a helper class
    public double[] medianSlidingWindow(int[] nums, int k) {
        MedianQueue window = new MedianQueue();
        double[] median = new double[nums.length - k + 1]; 
        for (int i = 0; i < nums.length; i++) {
            window.add(nums[i]);
            if (i >= k) window.remove(nums[i - k]);
            if (i >= k - 1) median[i - k + 1] = window.median();
        }   
        return median;
    }   

    static class MedianQueue {
        Queue<Long> maxHeap = new PriorityQueue<>(Collections.reverseOrder()), minHeap = new PriorityQueue<>();

        public void add(long n) {
            maxHeap.add(n);
            minHeap.add(maxHeap.poll());
        }   

        public double median() {
            while (maxHeap.size() - minHeap.size() >= 2) minHeap.offer(maxHeap.poll());
            while (minHeap.size() - maxHeap.size() >= 1) maxHeap.offer(minHeap.poll());
            return maxHeap.size() == minHeap.size() ? (maxHeap.peek() + minHeap.peek()) / 2.0 : maxHeap.peek();
        }   

        public boolean remove(long n) {
            return maxHeap.remove(n) || minHeap.remove(n);
        }
    }


----------------------------------------------------------------------------------------------------
Short and Clear O(nlogk) Java Solutions
public class Solution {
    public double[] medianSlidingWindow(int[] nums, int k) {
        double[] res = new double[nums.length - k + 1];
        int idx = 0;
        boolean useBoth = k % 2 == 0;
        TreeMap<Integer, Integer> small = new TreeMap<>((a, b)->{return (int)((double)b-a);});
        int smallSize = 0; 
        TreeMap<Integer, Integer> big = new TreeMap<>();
        int bigSize = 0;
        for(int i = 0; i<nums.length; i++){
            if(smallSize + bigSize == k){
                if(nums[i-k] <= small.firstKey()){
                    remove(small, nums[i-k]);
                    smallSize--;
                }else{
                    remove(big, nums[i-k]);
                    bigSize--;
                }
            }

            if(smallSize<=bigSize){
                add(small, nums[i]);
                smallSize++;
            }else{
                add(big, nums[i]);
                bigSize++;
            }
            if(bigSize>0){
                while(small.firstKey()>big.firstKey()){
                    add(big, remove(small, small.firstKey()));
                    add(small, remove(big, big.firstKey()));
                }
            }
            
            if(smallSize + bigSize==k){
                if(useBoth) res[idx++] = ((double)small.firstKey() + big.firstKey())/2.0;
                else res[idx++] = (double)small.firstKey();
            }
        }
        return res;
    }
    
    private int remove(TreeMap<Integer, Integer> map, int i){
        map.put(i, map.get(i)-1);
        if(map.get(i)==0) map.remove(i);
        return i; 
    }
    
    private void add(TreeMap<Integer, Integer> map, int i){
        if(!map.containsKey(i)) map.put(i, 1);
        else map.put(i, map.get(i)+1);
    }
}


----------------------------------------------------------------------------------------------------
Summary of Ideas and an accepting solution
from bisect import insort        
class Solution(object):
    def get_median(self, x):
        N = len(x)
        median = (x[N//2 - 1] + x[N//2])/2. if N % 2 == 0 else x[N//2]/1.
        return median
    
    def medianSlidingWindow(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: List[float]
        """
        window = sorted(nums[:k])
        result = []
        result.append(self.get_median(window))
        for i in range(k,len(nums)):
            window.remove(nums[i-k])
            insort(window, nums[i])
            result.append(self.get_median(window))
        return result


----------------------------------------------------------------------------------------------------
Java O(n * log(k)) solution, with a wrapped up TreeMap
    public double[] medianSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        double[] result = new double[n - k + 1];

        TreeMapDup left = new TreeMapDup();
        TreeMapDup right = new TreeMapDup();

        for (int i = 0; i < n; i++) {
            left.add(nums[i]);
            int leftMax = left.lastKey();
            left.remove(leftMax);
            right.add(leftMax);
            reBalance(left, right);

            int l = i - k + 1;
            if (l < 0) {
                continue;
            }

            result[l] = (double)left.lastKey();
            if (k % 2 == 0) {
                result[l] = (result[l] + (double)right.firstKey()) / 2.0;
            }
            int old = nums[l];
            if (!left.remove(old)) {
                right.remove(old);
            }
            reBalance(left, right);
        }

        return result;
    }

    private void reBalance(TreeMapDup left, TreeMapDup right) {
        if (left.size < right.size) {
            int rightMin = right.firstKey();
            right.remove(rightMin);
            left.add(rightMin);
        }
    }

    class TreeMapDup {
        int size;
        private final TreeMap<Integer, Integer> treeMap;
        public TreeMapDup() {
            treeMap = new TreeMap<>();
            size = 0;
        }

        int lastKey() {
            return treeMap.lastKey();
        }

        int firstKey() {
            return treeMap.firstKey();
        }

        void add(int key) {
            size++;
            treeMap.put(key, treeMap.getOrDefault(key, 0) + 1);
        }

        boolean remove(int key) {
            if (!treeMap.containsKey(key)) {
                return false;
            }

            size--;
            int size = treeMap.get(key);
            if (size == 1) {
                treeMap.remove(key);
            } else {
                treeMap.put(key, size - 1);
            }

            return true;
        }
    }


----------------------------------------------------------------------------------------------------
C++ two multiset solution
class Solution {
public:
    vector<double> medianSlidingWindow(vector<int>& nums, int k) {
        vector<double> res;
        multiset<int> u, l;
        int n = nums.size();
        for (int i = 0; i < n; ++i) {
            
            // Insert new number
            if (u.empty() or nums[i] >= *u.begin())
                u.insert(nums[i]);
            else l.insert(nums[i]);
            
            // Remove number out of the window
            if (i >= k) {
                if (nums[i-k] >= *u.begin())
                    u.erase(u.find(nums[i-k]));
                else l.erase(l.find(nums[i-k]));
            }
            
            // Balance the size of two sets
            while (u.size() < l.size()) {
                u.insert(*l.rbegin());
                l.erase(--l.end());
            }
            while (u.size() > l.size() + 1) {
                l.insert(*u.begin());
                u.erase(u.begin());
            }
            
            // Push back median
            if (i >= k-1) {
                if (k & 1) res.push_back(*u.begin());
                else res.push_back(((double)*u.begin() + *l.rbegin()) / 2);
            }
        }
        return res;
    }
};

----------------------------------------------------------------------------------------------------
O(n*log(k)) 79 ms Indexed priority queue C++ solution with explanation (accepted).
class Solution {
    class IndexPQ {
        int N{0};
        int maxN;
        std::vector<int> pq;
        std::vector<int> qp;
        std::vector<int> keys;
        bool isMin{false};
        public:
        IndexPQ(int maxN, bool isMin): maxN(maxN), isMin(isMin) {
            qp = std::vector<int>(maxN + 1, -1);
            pq = std::vector<int>(maxN + 1, -1);
            keys = std::vector<int>(maxN + 1, -1);
        }
        
        bool contains(int i) {
            return (qp[i] != -1);
        }
        
        void insert(int i, int key) {
            qp[i] = N;
            pq[N] = i;
            keys[i] = key;
            swim(N);
            N++;
        }
        
        int topKey() {
            return keys[pq[0]];
        }
        
        int deleteTop() {
            int indexOfTop = pq[0];
            exch(0, --N);
            sink(0);
            qp[pq[N]] = -1;
            pq[N] = -1;
            return indexOfTop;
        }
        
        int count() {
            return N;
        }
        
        void deleteIndex(int i) {
            int index = qp[i];
            exch(index, --N);
            swim(index);
            sink(index);
            pq[N] = -1;
            qp[i] = -1;
        }
        
        void sink(int k) {
            while(2*k + 1 < N) {
                int j = 2*k + 1;
                if ((j + 1) < N && less(j, j+1)) j++;
                if (!less(k, j)) break;
                exch(k, j);
                k = j;
            }
        }
        
        void swim(int k) {
            while(k > 0 && less((k-1)/2, k)) {
                exch((k-1)/2, k);
                k = (k-1)/2;
            }
        }
        
        bool less(int i, int j) {
            if (isMin) {
                return keys[pq[i]] > keys[pq[j]];
            } else {
                return keys[pq[i]] < keys[pq[j]];
            }
        }
        
        void exch(int i, int j) {
            int t = qp[pq[i]];
            qp[pq[i]] = qp[pq[j]];
            qp[pq[j]] = t;
            t = pq[i];
            pq[i] = pq[j];
            pq[j] = t;
        }
    };
    
public:
    vector<double> medianSlidingWindow(vector<int>& nums, int k) {
        vector<double> solution;
        // Trivial cases
        if (nums.size() == 0) {
            return solution;
        }
        if (k == 1) {
            for(auto v: nums) {
                solution.push_back(double(v));
            }
            return solution;
        }
        
        int mid = (k - 1)/2;
        if (k >= nums.size()) {
            k = nums.size();   
        }
        
        std::vector<int> subvector(nums.begin(), nums.begin() + k);
        // Shuffle -- O(n) Partition -- O(n)
        std::random_shuffle(subvector.begin(), subvector.end());
        std::nth_element(subvector.begin(), subvector.begin() + mid, subvector.end());
        int median = subvector[mid];
        
        IndexPQ minPQ(nums.size(), true);
        IndexPQ maxPQ(nums.size(), false);
        
        // Insertion based on median -- O(n)
        for (int i = 0; i < k; i++) {
            if (nums[i] > median) {
                minPQ.insert(i, nums[i]);
            } else {
                maxPQ.insert(i, nums[i]);
            }
        }
        
        // If there are lot of elements equal to the median, we need to rebalance the 2 PQs
        // O(n)
        while(1) {
            auto minc = minPQ.count();
            auto maxc = maxPQ.count();
            if (maxc == 0 || (minc > maxc && (minc - maxc) > 1)) {
                int index = minPQ.deleteTop();
                maxPQ.insert(index, nums[index]);
            } else if (minc == 0 || (maxc > minc && (maxc - minc) > 1)) {
                int index = maxPQ.deleteTop();
                minPQ.insert(index, nums[index]);
            } else {
                break;
            }
        }
        
        
        // At most there are k elements in the heap
        for (int j = 0,i = k; i < nums.size(); i++,j++) {
            // O(lgK)
            int topMin = minPQ.topKey();
            int topMax = maxPQ.topKey();
            solution.push_back((k%2)? topMax:((double)(topMin) + (double)topMax)/2);
            
            // We need two cases here. If there were lot of similar elements distributed across both minPQ and maxPQ
            // We also have to verify if the element being removed was actually in minPQ.
            if (nums[j] > topMax || (nums[j] == topMin && !maxPQ.contains(j))) {
                minPQ.deleteIndex(j);
                if (nums[i] > topMax) {
                    minPQ.insert(i, nums[i]);
                } else {
                    maxPQ.insert(i, nums[i]);
                    int index = maxPQ.deleteTop();
                    minPQ.insert(index, nums[index]);
                }
            } else {
                maxPQ.deleteIndex(j);
                if (nums[i] <= topMax) {
                    maxPQ.insert(i, nums[i]);
                } else {
                    minPQ.insert(i, nums[i]);
                    int index = minPQ.deleteTop();
                    maxPQ.insert(index, nums[index]);
                }
            }
        }
        int topMin = minPQ.topKey();
        int topMax = maxPQ.topKey();
        solution.push_back((k%2)? topMax:((double)(topMin) + (double)topMax)/2);
        
        return solution;
    }
};


----------------------------------------------------------------------------------------------------
Java Using Two PriorityQueues To Conquer
import java.util.Collections;
import java.util.PriorityQueue;
public class Solution {
    public double[] medianSlidingWindow(int[] nums, int k) {
        if(nums==null || nums.length==0 || k==0) return new double[0];
        double[] res = new double[nums.length - k + 1];
        PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(k, Collections.reverseOrder());
        PriorityQueue<Integer> minHeap = new PriorityQueue<Integer>(k);
        int idx = 0;
        for(int i=0; i<nums.length; i++){
            if(maxHeap.isEmpty() || nums[i]<maxHeap.peek()){
                maxHeap.add(nums[i]);
            }else{
                minHeap.add(nums[i]);
            }
            
            if(minHeap.size() > maxHeap.size()){
                maxHeap.add(minHeap.poll());
            }
            
            if(maxHeap.size() > minHeap.size()+1){
                minHeap.add(maxHeap.poll());
            }
            
            if(i>=k-1){
                if (k % 2 == 1) {
                    res[idx] = (1.0 * maxHeap.peek());
                }
                else {
                    res[idx] = (maxHeap.peek()/2.0 + minHeap.peek()  / 2.0);
                }
                idx += 1;
                int toRemove = nums[i-k+1];
                if(toRemove<=maxHeap.peek()){
                    maxHeap.remove(toRemove);
                }else{
                    minHeap.remove(toRemove);
                }
                if(minHeap.size() > maxHeap.size()){
                    maxHeap.add(minHeap.poll());
                }
                if(maxHeap.size() > minHeap.size()+1){
                    minHeap.add(maxHeap.poll());
                }
            }
        }
        
        return res;
    }
}


----------------------------------------------------------------------------------------------------
C++ O(N*logK) using two std::set
    vector<double> medianSlidingWindow(vector<int>& nums, int k) {
        vector<double> res;
        multiset<int> st1, st2;
        for(int i=0;i<nums.size();i++) {
            if(i>=k) {
                if(st1.count(nums[i-k])) st1.erase(st1.find(nums[i-k]));
                else if(st2.count(nums[i-k])) st2.erase(st2.find(nums[i-k]));
            }
            if(st1.size()<=st2.size()) {
                if(st2.empty() || nums[i]<=*st2.begin()) st1.insert(nums[i]);
                else {
                    st1.insert(*st2.begin());
                    st2.erase(st2.begin());
                    st2.insert(nums[i]);
                }
            }
            else {
                if(nums[i]>=*st1.rbegin()) st2.insert(nums[i]);
                else {
                    st2.insert(*st1.rbegin());
                    st1.erase(--st1.end());
                    st1.insert(nums[i]);
                }                
            }
            if(i>=(k-1)) {
                if(k%2) res.push_back(*st1.rbegin());
                else res.push_back(((double)*st1.rbegin()+(double)*st2.begin())/2);
            }
        }
        return res;
    }


----------------------------------------------------------------------------------------------------
My space-saving Java solution
public class Solution {
    public double[] medianSlidingWindow(int[] nums, int k) {
        if(nums == null || nums.length < 1 || k < 1) return null;
        int len = nums.length, i = 0;
        double[] res = new double[len-k+1];
        SortedArray array = new SortedArray();
        while(i<len){
            if(i-k+1>0)
                array.delete(nums[i-k]);
            array.add(nums[i++]);
            if(i-k>=0){
                if(k % 2 == 0)
                    res[i-k] = array.get((k>>>1)-1)/2.0 + array.get(k>>>1)/2.0;
                else
                    res[i-k] = array.get(k>>>1);
            }
        }
        return res;
        
    }
    
    class SortedArray{
        
        List<Integer> array;
        
        SortedArray(){
            array = new ArrayList<Integer>();
        }
        
        void add(int val){
            int i = array.size()-1;
            while(i>=0&&array.get(i)>val) i--;
            array.add(i+1, val);
        }
        
        void delete(int val){
            array.remove((Integer)val);
        }
        
        int get(int val){
            return array.get(val);
        }
    }
}


----------------------------------------------------------------------------------------------------
Java beats 97% used sorts list
 public List<Double> list=new ArrayList<Double>();
    public double[] medianSlidingWindow(int[] nums, int k) {
        for(int i=0;i<k;i++){
            add(nums[i]);
        }
        double[] ret=new double[nums.length-k+1];
        ret[0]=getmean();
        for(int i=k;i<nums.length;i++){
            add(nums[i]);
            remove(nums[i-k]);
            ret[i-k+1]=getmean();
        }
        return ret;
    }
    public double getmean(){
        int size=list.size();
        if(size%2==1) return list.get(size/2);
        else return (list.get(size/2)+list.get(size/2-1))/2;
    }
    public void remove(int i){
        list.remove(find(i));
    }
    public void add(int i){
        list.add(find(i),(double)i);
    }
    public int find(int i){
        int st=0,ed=list.size();
        while(st<ed){
            int mid=st+(ed-st)/2;
            if(list.get(mid)>i){
                ed=mid;
            }else if(list.get(mid)==i){
                return mid;
            }else{
                st=mid+1;
            }
        }
        return st;
    }


----------------------------------------------------------------------------------------------------
Java Beats 98%  O(Nlgk) BST solution
 public double[] medianSlidingWindow(int[] nums, int k) {

     List<Integer> window = new ArrayList<Integer>();
     double []res = new double[nums.length-k+1];
     for(int i=0; i<nums.length; i++){
         if(i>=k) res[i-k] = (k%2==0?((double)window.get(k/2)+(double)window.get(k/2-1))/2:(double)window.get(k/2));
         window.add(find(window, nums[i]), nums[i]);
         if(i>=k) window.remove(find(window, nums[i-k]));
     }         
     res[res.length-1] = (k%2==0?((double)window.get(k/2)+(double)window.get(k/2-1))/2:(double)window.get(k/2));
     return res;
}

public int find(List<Integer> list, int target){
    int start =0, end = list.size()-1;
    while(start<=end){
        int mid = start + (end-start)/2;
        if(list.get(mid)<target){
            start = mid +1;
        }else if (list.get(mid)>target){
            end = mid -1;
        }else{
            return mid;
        }
    }
    return start;
}

----------------------------------------------------------------------------------------------------
